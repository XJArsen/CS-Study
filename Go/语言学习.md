*主要记录C/C++不同和新增的地方*

# 变量
## 变量声明
1.标准声明
```go
var 变量名 变量类型
```
2.批量声明
```go
var (
	变量名 变量类型
	变量名 变量类型
	...
)
```

## 变量初始化
1.标准初始化
```go
var 变量名 类型 = 表达式
```
2.多个变量初始化，例如：
```go
var name, age = "Q1mi", 20
```
3.类型推导
	变量的类型省略，这个时候编译器会根据等号右边的值来推导变量的类型完成初始化，例如

```go
var name = "Jarson"
var age = 19
```
4.短变量声明
	在函数内部，可以使用更简略的 `:=` 方式声明并初始化变量。

```go
func main() {
	n := 10
	m := 200 // 此处声明局部变量m
	fmt.Println(m, n)
}
```
*:=不能使用在函数外*

#### 匿名变量
在使用多重赋值时，如果想要忽略某个值，可以使用**匿名变量**（anonymous variable）。 匿名变量用一个下划线`_`表示，例如：
```go
func foo() (int, string) {
	return 10, "Q1mi"
}
func main() {
	x, _ := foo()
	_, y := foo()
	fmt.Println("x=", x)
	fmt.Println("y=", y)
}
```
*匿名变量不占用命名空间，不会分配内存，所以匿名变量之间不存在重复声明*
*_多用于占位，表示忽略值*
### 常量
基础部分 把var换成const即可
#### iota
iota是go语言的常量计数器，只能在常量的表达式中使用。

iota在const关键字出现时将被重置为0。const中每新增一行常量声明将使iota计数一次(iota可理解为const语句块中的行索引)。 使用iota能简化定义，在定义枚举时很有用。
例如：
```go
const (
		n1 = iota //0
		n2        //1
	)
```
技巧 ：
1.使用`_`跳过某些值
2.定义数量级
3.`iota`声明中间插队, 例如
```go
const (
		n1 = iota //0
		n2 = 100  //100
		n3 = iota //2
		n4        //3
	)
	const n5 = iota //0
```
4.多个`iota`定义在一行,例如：
```go
const (
		a, b = iota + 1, iota + 2 //1,2
		c, d                      //2,3
	)
```
# 数据类型

* 一般类型

| 类型    | 描述                                                         |
| ------- | ------------------------------------------------------------ |
| uint8   | 无符号 8位整型 (0 到 255)                                    |
| uint16  | 无符号 16位整型 (0 到 65535)                                 |
| uint32  | 无符号 32位整型 (0 到 4294967295)                            |
| uint64  | 无符号 64位整型 (0 到 18446744073709551615)                  |
| int8    | 有符号 8位整型 (-128 到 127)                                 |
| int16   | 有符号 16位整型 (-32768 到 32767)                            |
| int32   | 有符号 32位整型 (-2147483648 到 2147483647)                  |
| int64   | 有符号 64位整型 (-9223372036854775808 到 9223372036854775807) |
| float32 | 3.4e38       （IEEE 754标准）                                |
| float64 | 1.8e308     （IEEE 754标准）                                 |
* 特殊类型

| 类型    | 描述                                                   |
| ------- | ------------------------------------------------------ |
| uint    | 32位操作系统上就是`uint32`，64位操作系统上就是`uint64` |
| int     | 32位操作系统上就是`int32`，64位操作系统上就是`int64`   |
| uintptr | 无符号整型，用于存放一个指针                           |

* 字符串类型

1.多行字符串：

Go语言中要定义一个多行字符串时，使用反引号字符，例如

```go
s1 := `第一行
第二行
第三行
`
fmt.Println(s1)
```

*反引号间换行将被作为字符串中的换行，但是所有的转义字符均无效，文本将会原样输出。*

2.byte和rune

Go 语言的字符有以下两种：

1. `uint8`类型，或者叫 byte 型，代表一个`ASCII码`字符。
2. `rune`类型，代表一个 `UTF-8字符`。

Go 语言的字符有以下两种：

1. `uint8`类型，或者叫 byte 型，代表一个`ASCII码`字符。

2. `rune`类型，代表一个 `UTF-8字符`。

   

Go 使用了特殊的 rune 类型来处理 Unicode，让基于 Unicode 的文本处理更为方便，也可以使用 byte 型进行默认字符串处理，性能和扩展性都有照顾。例如：

```go
// 遍历字符串
func traversalString() {
	s := "hello沙河"
	for i := 0; i < len(s); i++ { //byte
		fmt.Printf("%v(%c) ", s[i], s[i])
	}
	fmt.Println()
	for _, r := range s { //rune
		fmt.Printf("%v(%c) ", r, r)
	}
	fmt.Println()
}
```

3. 修改字符串

​	要修改字符串，需要先将其转换成`[]rune`或`[]byte`，完成后再转换为`string`。无论哪种转换，都会重新分配内存，并复制字节数组。

```go
func changeString() {
	s1 := "big"
	// 强制类型转换
	byteS1 := []byte(s1)
	byteS1[0] = 'p'
	fmt.Println(string(byteS1))

	s2 := "白萝卜"
	runeS2 := []rune(s2)
	runeS2[0] = '红'
	fmt.Println(string(runeS2))
}
```



# 流程控制

## 分支结构
**1.if else** 
基本写法不变
特殊写法：
可以在 if 表达式之前添加一个执行语句，再根据变量值进行判断，如下：

```go
func ifDemo2() {
	if score := 65; score >= 90 {
		fmt.Println("A")
	} else if score > 75 {
		fmt.Println("B")
	} else {
		fmt.Println("C")
	}
}
```
**2.switch**
只需注意switch不加()即可,且caseh后面可以加多个变量值.
case结束后无`break`

新特性：`fallthrough`语法可以执行满足条件的case的下一个case，是为了兼容C语言中的case设计的。

例如:

```go
switch a {
	case 1:
		fmt.Println("1")
	case 2,3,4:
		fmt.Println("2")
	default:
		fmt.Println("3")
	}
```
#### 循环结构
**1.for**


> 基本写法：
```go
for 初始语句;条件表达式;结束语句{
    循环体语句
}
```
*注意for后面不接()*

> 无限循环

```go
for {
    循环体语句
}
```
**2.for range**
Go语言中可以使用for range遍历数组、切片、字符串、map 及通道（channel）。 通过for range遍历的返回值有以下规律：

 1. 数组、切片、字符串返回索引和值。
 2. map返回键和值。
 3. 通道（channel）只返回通道内的值。

```go
for key, val := range coll {
  ...
}
```



# 数据结构

## 数组
**1.基本声明语法**

```go
var 数组变量名 [元素数量]T
```
**2.改变**

* C/C++中`[]`改为`[...]`(在GO语言中`[]`用于切片的声明)
* 指定索引来初始化数组，例如：
```go
a := [...]int{1: 1, 3: 5}	// [0 1 0 5]
```


## 切片

切片（Slice）是一个拥有相同类型元素的可变长度的序列。它是基于数组类型做的一层封装。它非常灵活，支持自动扩容。
切片是一个引用类型，它的内部结构包含地址、长度和容量。切片一般用于快速地操作一块数据集合。

*可以类比C++中vector* 

**1.基本声明语法**

```go
var name []T
```

**2.切片的长度和容量**

切片拥有自己的长度和容量，我们可以通过使用内置的`len()`函数求长度，使用内置的`cap()`函数求切片的容量。

**3.切片表达式**

* 简单切片表达式

	切片表达式中的`low`和`high`表示一个索引范围（左闭右开）
	切片`长度=high-low`，容量等于得到的切片的底层数组的量。如下：
```go
a := [5]int{1, 2, 3, 4, 5}
s := a[1:3]
```
 可以省略切片表达式中的任何索引。省略了low则默认为0；省略了high则默认为切片操作数的长度:
* 复杂切片表达式
 对于数组，指向数组的指针，或切片a(注意不能是字符串)支持完整切片表达式：
```go
a[low : high : max]
```
其中max为切片的默认初始容量
* 使用make()函数构造切片
使用格式：
```go
make([]T, size, cap)
```
**4.其他**

* 切片的比较

	切片之间是不能比较的，我们不能使用`==`操作符来判断两个切片是否含有全部相等元素。 切片唯一合法的比较操作是和`nil`比较。 一个`nil`值的切片并没有底层数组.

	所以要判断一个切片是否是空的，要是用`len(s) == 0`来判断

* 赋值和copy()

 切片的赋值是应用的形式,copy()完成复制操作,例如

  ```go
  a := []int{1, 2, 3, 4, 5}
  b := a
  c := make([]int, 5, 5)
  copy(c, a) 
  ```

 a和b会指向同一块地址,但是c不会。修改b会修改a，但是修改c不会。

* 添加

 使用函数append()，如下

  ```go
  s = append(s, 1, 2, 3)
  ```

* 删除
  Go语言中并没有删除切片元素的专用方法，我们只能使用切片本身的特性来删除元素，例如：

```go
a := []int{30, 31, 32, 33, 34, 35, 36, 37}
  	// 要删除索引为2的元素
a = append(a[:2], a[3:]...)
```

## map

与C++大致相同

区别：

| 操作         | C++            | GO                                        |
| ------------ | -------------- | ----------------------------------------- |
| 删除         | erase()        | delete()                                  |
| 定义         | map<key,value> | map[key]value  make(map[key]value, [cap]) |
| 某键是否存在 | count()        | value, ok := map[key]                     |

# 函数

## 函数定义

* 语法

```go
func 函数名(参数 参数类型,)(返回值){
    函数体
}
```



* 参数

函数的参数中如果相邻变量的类型相同，则可以省略类型，例如：

```go
func intSum(x, y int) int {
	return x + y
}
```

可变参数是指函数的参数数量不固定。Go语言中的可变参数通过在参数名后加`...`来标识。如下：

```go
func intSum2(x ...int) int {
	fmt.Println(x) //x是一个切片
	sum := 0
	for _, v := range x {
		sum = sum + v
	}
	return sum
}
```

如果要固定函数和可变参数一起使用，可变参数要在固定参数后。本质上，函数的可变参数是通过切片来实现的。

* 返回值

**多返回值**
Go语言中函数支持多返回值，函数如果有多个返回值时必须用`()`将所有返回值包裹起来。

**返回值命名**
函数定义时可以给返回值命名，并在函数体中直接使用这些变量，最后通过return关键字返回
如下：

```go
func calc(x, y int) (sum, sub int) {
	sum = x + y
	sub = x - y
	return
}
```
**返回值补充**
当我们的一个函数返回值类型为slice时，nil可以看做是一个有效的slice，没必要显示返回一个长度为0的切片。
```go
func someFunc(x string) []int {
	if x == "" {
		return nil // 没必要返回[]int{}
	}
	...
}
```

## 函数类型

*类比C的函数指针*
我们可以使用`type`关键字来定义一个函数类型，具体格式如下：

```go
type C func(int, int) int
```

上面语句定义了一个`C`类型，它是一种函数类型，这种函数接收两个int类型的参数并且返回一个int类型的返回值。

同C一样也可以进行赋值操作

## 高阶函数
1.函数可以作为参数
2.函数可以作为返回值

## 匿名函数

在Go语言中函数内部不能再像之前那样定义函数了，只能定义匿名函数，格式如下：

```go
func(参数)(返回值){
    函数体
}
```

匿名函数因为没有函数名，所以没办法像普通函数那样调用，所以匿名函数需要保存到某个变量或者作为立即执行函数:

例如:

> 匿名函数多用于实现回调函数和闭包。

## 闭包

闭包指的是一个函数和与其相关的引用环境组合而成的实体。简单来说，`闭包=函数+引用环境`。 例子：

```go
func adder() func(int) int {
	var x int
	return func(y int) int {
		x ++
		return x
	}
}
```

一个闭包中一个函数和多个元素（引用环境）。

量`f`是一个函数并且它引用了其外部作用域中的`x`变量，此时`f`就是一个闭包。 在`f`的生命周期内，变量`x`也一直有效。 闭包进阶示例1：

#### defer语句

Go语言中的`defer`语句会将其后面跟随的语句进行延迟处理。在`defer`归属的函数即将返回时，将延迟处理的语句按`defer`定义的逆序进行执行，也就是说，先被`defer`的语句最后被执行，最后被`defer`的语句，最先被执行。

由于`defer`语句延迟调用的特性，所以`defer`语句能非常方便的处理资源释放问题。比如：资源清理、文件关闭、解锁及记录时间等。

`defer`语句的执行在`return`之后

## panic/recover

介绍：有些情况，当程序发生异常时，无法继续运行。在这种情况下，我们会使用 panic 来终止程序。当函数发生 panic 时，它会终止运行，在执行完所有的延迟函数后，程序控制返回到该函数的调用方。这样的过程会一直持续下去，直到当前协程的所有函数都返回退出，然后程序会打印出 panic 信息，接着打印出堆栈跟踪（Stack Trace），最后程序终止。

程序运行期间中引发了`panic`导致程序崩溃，异常退出了。这个时候我们就可以通过`recover`将程序恢复回来，继续往后执行。

例如：

```go
func funcB() {
	defer func() {
		err := recover()
		//如果程序出出现了panic错误,可以通过recover恢复过来
		if err != nil {
			fmt.Println("recover in B")
		}
	}()
	panic("panic in B")
}

```



# 指针

区别于C/C++中的指针，Go语言中的指针不能进行偏移和运算，是安全指针。

**语法：**

```go
ptr := &v    // v的类型为T
```

在GO语言中，取地址操作符`&`和取值操作符`*`是一对互补操作符，`&`取出地址，`*`根据地址取出地址指向的值。

## new和make

Go语言中对于引用类型的变量，我们在使用的时候不仅要声明它，还要为它分配内存空间，否则我们的值就没办法存储。而对于值类型的声明不需要分配内存空间，是因为它们在声明的时候已经默认分配好了内存空间。要分配内存，就引出来今天的new和make。 Go语言中new和make是内建的两个函数，主要用来分配内存。

### new

语法：

```go
func new(Type) *Type
```

- Type表示类型，new函数只接受一个参数，这个参数是一个类型
- *Type表示类型指针，new函数返回一个指向该类型内存地址的指针。

实例如下：
```go
func main() {
	a := new(int)
	b := new(bool)
	fmt.Printf("%T\n", a) // *int
	fmt.Printf("%T\n", b) // *bool
	fmt.Println(*a)       // 0
	fmt.Println(*b)       // false
}	
```

### make

```go
func make(t Type, size ...IntegerType) Type
```

make函数是无可替代的，我们在使用slice、map以及channel的时候，都需要使用make进行初始化，然后才可以对它们进行操作。

实例如下：

```go
func main() {
	var b map[string]int
	b = make(map[string]int, 10)
	b["沙河娜扎"] = 100
	fmt.Println(b)
}
```


### 区别

1. 二者都是用来做内存分配的。
2. make只用于slice、map以及channel的初始化，返回的还是这三个引用类型本身；
3. 而new用于类型的内存分配，并且内存对应的值为类型零值，返回的是指向类型的指针。

# 结构体

