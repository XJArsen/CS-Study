# 基础算法



## 快速选择算法

```c++
int quick_select(int l,int r,int k){
	int i = l -  1,j = r + 1,x;
	if(l == r) return a[l];
	x = a[l];
	while(i < j) {
		while(a[++i] < x);
		while(a[--j] > x);
		if(i < j) swap(a[i],a[j]);
	}
	int s = j - l + 1;
	if(k <= s) return quick_select(l,j,k);
	else return quick_select(j + 1,r,k - s);
}
```


## 二分算法

### 整数二分

* 

```c++
int bsearch(int l,int r) {
	while(l < r) {
		int mid = r + l >> 1;
			if(check(mid)) r = mid;
            else l = mid + 1;
		}
	}
	return l;
}
```
* 
```c++
int bsearch(int l,int r) {
    while(l < r) {
        int mid = l + r + 1 >> 1;
        if(check(mid)) l = mid;
        else r = mid - 1;
    }
    return l;
}
```
### 浮点数二分
```c++
double bsearch(double l,double r) {
    const double eps = 1e-8;
    while(r - l > eps) {
        double mid = (l + r) / 2;
        if(check()) r = mid;
        else l = mid;
    }
    return l;
}
```



## 二维前缀和算法

以(x1,y1)为左上角，(x2,y2)为右下角的矩阵得和
```c++
	sum[x2][y2] + sum[x1 - 1][y1 - 1] - sum[x1 - 1][y2] - sum[x2][y1 - 1]
```


## 差分算法

```c++
void in(int l,int r,int c){
	b[l] += c;
	b[r + 1] -= c;
}
```
### 二维差分
```c++
void in(int x1,int y1,int x2,int y2,int c) {
    b[x1][y1] += c;
    b[x2 + 1][y1] -= c;
    b[x1][y2 + 1] -= c;
    b[x2 + 1][y2 + 1] += c;
}
```


## 高精度算法

### 高精度加法
```c++
vector<int> add(vector<int> &a,vector<int> &b) {
	if(a.size() < b.size()) return add(b,a);
	vector<int> c;
	int t = 0;
	for(int i = 0;i < a.size(); i++) {
		t += a[i];
		if(i < b.size()) t += b[i];
		c.pb(t % 10);
		t /= 10;
	}
	if(t) c.pb(t);
	return c;
}
```
### 高精度减法
```c++
bool compare(vector<int> &a,vector<int> &b) {
	if(a.size() != b.size()) return a.size() > b.size();
	for(int i = a.size() - 1;i >= 0; i--) {
		if(a[i] != b[i]) return a[i] > b[i];
	}
	return true;
}

vector<int> sub(vector<int> &a,vector<int> &b) {
	vector<int> c;
	for(int i = 0,t = 0;i < a.size(); i++) {
		t = a[i] - t;
		if(i < b.size()) t -= b[i];
		c.pb((t + 10) % 10);
		if(t < 0) t = 1;
		else t = 0;
	}
	while(c.size() > 1 && c.back() == 0) c.pop_back();
	return c;
}
```
### 高精度乘法

```c++
vector<int> mul(vector<int> &a,int b) {
	vector<int> c;
	int t = 0;
	for(int i = 0; i < a.size() || t;i++) {
		if(i < a.size()) t += a[i] * b;
		c.push_back(t % 10);
		t /= 10;
	}
	while(c.size() > 1 && c.back() == 0) c.pop_back();
	return c;
}
```

### 高进度除法

a是被除数，b是除数，r是余数。

```c++
vector<int > div(vector<int> &a,int b,int &r) {
	vector<int> c;
	r = 0;
	for(int i = a.size() - 1; i >= 0; i--) {
		r = r * 10 + a[i];
		c.push_back(r / b);
		r %= b;
	}
	reverse(c.begin(),c.end());
	while(c.size() > 1 && c.back() == 0) c.pop_back;
	return c;
}
```




# 数论算法

## 快速幂
### (1)普通算法

```C++
ll qmi(ll a,ll k,ll p) {
	ll res = 1,t = a;
	while(k) {
		if(k & 1) res = res * t % p;
		t = t * t % p;
		k >>= 1;
	}
	return res;
}
```
#### 高精度算法
```c++
char k[N];

ll kmi(ll a,ll p){
	ll m ,n;
	ll res = 1;
	for(ll i = strlen(k) - 1;i >= 0;i--){
		m = k[i] - '0';
		for(ll j = 0; j < m; j++) res = res * a % p;
		n = 1;
		for(int j = 0; j < 10; j++) n = n * a % p;
		a = n;
	}
	return res;
}
```



## 线性质数筛
```c++
int primes[N],cnt = 0;
bool vis[N];

void get_primes(int n) {
    for(int i = 2;i <= n; i++) {
        if(!vis[i]) primes[cnt++] = i;
        for(int j = 0;primes[j] <= n / i; j++) {
            vis[primes[j] * i] = true;
            if(i % primes[j] == 0) break;     
        }
    }
}
```



## 欧几里得算法 
普通
```c++
int gcd(int a,int b) {
	return b ? gcd(b,a % b) : a;
}
```
拓展
```c++
void exgcd(ll a, ll b, ll &d, ll &x, ll &y) {
    if (!b) d = a, x = 1, y = 0;
    else exgcd(b, a % b, d, y, x), y -= x * (a / b);
}
```

## 约数
## 求多个数约数
```c++
 unordered_map<int, int> primes;
    while (n--) {
        int x;
        cin >> x;
        for (int i = 2; i <= x / i; i++) {
            while (x % i == 0) {
                x /= i;
                primes[i]++;
            }
        }
        if (x > 1) primes[x]++;
    }
```
### 约数个数
```c++
    modint res = one;
	for (auto it : primes) res *= (it.se + 1);
```
### 约数之和
```c++
modint res = one;
    for (auto it : primes) {
        modint a = it.fi, b = it.se;
        modint t = 1;
        modint x = 1;
        while (b.v--) t = (t * a + 1);
        res *= t;
    }
```
## 组合数
### 小查询
```
for(int i = 0;i < N;i++){
		for(int j = 0;j <= i; j++){
			if(!j) c[i][j] = 1;
			else c[i][j] = (c[i - 1][j - 1] + c[i - 1][j]) % mod;
		}
	}
```
### 大查询
```c++
namespace CMN
{
int fact[N], infact[N];
int qpow(long long a, long long k)
{
    ll res = 1, t = a;
    while (k)
    {
        if (k & 1)
            res = res * t % mod;
        t = t * t % mod;
        k >>= 1;
    }
    return res;
}
void init()
{
    fact[0] = infact[0] = 1;
    for (int i = 1; i < N; i++)
    {
        fact[i] = (ll)fact[i - 1] * i % mod;
        infact[i] = (ll)qpow(fact[i], mod - 2) % mod;
    }
}
int C(int a, int b)
{
    return (ll)fact[a] * infact[b] % mod * infact[a - b] % mod;
}
}; // namespace CMN
```

##  Fibonacci

### 第n项

```c++
pair<int, int> fib(int n) {
	if (n == 0) return {0, 1};
	auto [a, b] = fib(n >> 1);
	int c = a * (2 * b - a) % m, d = a * a % m + b * b % m;
	if (n & 1) return {d, c + d};
	return {c, d};
}
```

### 前n项和

```c++
fib(n + 2) - 1;
```



## 中国剩余定理

朴素

```c++
long long CRT(int k, long long* a, long long* r) {
    long long n = 1, ans = 0;
    for (int i = 1; i <= k; i++) n = n * r[i];
    for (int i = 1; i <= k; i++) {
        long long m = n / r[i], b, y, d;
        exgcd(m, r[i], d, b, y);  // b * m mod r[i] = 1
        ans = (ans + a[i] * m * b % n) % n;
    }
    return (ans % n + n) % n;
}
```

扩展

```c++
pll excrt(pll l, pll r) {
    auto[r1, m1] = l;
    auto[r2, m2] = r;
    if (r1 == -1 || r2 == -1) return {-1, -1};
    ll d, l1, l2;
    exgcd(m1, m2, d, l1, l2);
    if ((r2 - r1) % d) return {-1, -1};
    ll L = m1 * m2 / d;
    ll R = ((r1 + (r2 - r1) / d * l1 % L * m1) % L + L) % L;
    return {R, L};
}
```



```c++
long long ExCRT(const vector<long long>& a, const vector<long long>& p) {
    long long n = p[0], ans = a[0];
    int len = a.size();
    for (int i = 1 ; i < len ; i++) {
        long long x, y;
        long long c = (a[i] - ans % p[i] + p[i]) % p[i];
        long long d = Exgcd(n, p[i], x, y);
        if (c % d != 0) {
            return -1LL;
        }
        long long g = p[i] / d;
        x = (__int128) x * c / d % g;
        ans += x * n;
        n *= g;
        ans = (ans % n + n) % n; 
    }
    return ans;
}
```





# 数据结构

## 字符串
### KMP算法

```c++
struct KMP {
    vector<int> nx;
    vector<long long> b;

    KMP(vector<long long>& b) {
        this->b = b;
        int n = b.size();
        int j = 0;
        nx.resize(n);
        for (int i = 1; i < n; i++) {
            while (j > 0 && b[i] != b[j]) j = nx[j - 1];
            if (b[i] == b[j]) j++;
            nx[i] = j;
        }
    }
    int find(vector<long long>& a) {
        int n = b.size(), m = a.size();
        int j = 0;
        long long ans = 0;
        for (int i = 0; i < m; i++) {
            while (j > 0 && a[i] != b[j]) j = nx[j - 1];
            if (a[i] == b[j]) j++;
            if (j == n) {
                //匹配位点:i-n+1
                ans++;
                j = nx[j - 1];
            }
        }
        return ans;
    }
    int getBorder() { return nx.back(); }
};
```

### Z函数

```C++
vector<int> zFunction(string s) {
    int n = s.size();
    vector<int> z(n + 1);
    z[0] = n;
    for (int i = 1, j = 1; i < n; i++) {
        z[i] = max(0, min(j + z[j] - i, z[i - j]));
        while (i + z[i] < n && s[z[i]] == s[i + z[i]]) {
            z[i]++;
        }
        if (i + z[i] > j + z[j]) {
            j = i;
        }
    }
    return z;
}
```



### 字典树

#### trie

```c++
struct trie
{
    int nex[N][26], idx;
    int cnt[N];

    // 插入字符串
    void insert(string s, int l)
    {
        int p = 0;
        for (int i = 0; i < l; i++)
        {
            int c = s[i] - 'a';
            if (!nex[p][c])
                nex[p][c] = ++idx;
            p = nex[p][c];
        }
        cnt[p]++;
    }
    // 查找字符串
    int find(string s, int l)
    {
        int p = 0;
        for (int i = 0; i < l; i++)
        {
            int c = s[i] - 'a';
            if (!nex[p][c])
                return 0;
            p = nex[p][c];
        }
        return cnt[p];
    }
};

```

#### 01-trie

```c++
struct trie_01 {
    int nex[N * 31][2], idx;
    int a[N], sz[N];
    void Insert(int x) {
        int p = 0;
        for (int i = 31; ~i; i--) {
            int c = x >> i & 1;
            if (!nex[p][c]) nex[p][c] = ++idx;
            p = nex[p][c];
            sz[p]++;
        }
    }
    void Delete(int x) {
        int p = 0;
        for (int i = 31; ~i; i--) {
            int c = x >> i & 1;
            if (!nex[p][c]) nex[p][c] = ++idx;
            p = nex[p][c];
            sz[p]--;
        }
    }
    int Query(int x) {
        int p = 0, res = 0;
        for (int i = 30; ~i; i--) {
            int s = x >> i & 1;
            if (nex[p][!s]) {
                res += 1 << i;
                p = nex[p][!s];
            } else {
                p = nex[p][s];
            }
        }
        return res;
    }
};
```

### AC自动机

* 输出总次数

```c++
namespace AC {
int tr[N][26], tot;
int e[N], fail[N];

void insert(string s) {
    int u = 0;
    for (char i : s) {
        if (!tr[u][i - 'a']) tr[u][i - 'a'] = ++tot;
        u = tr[u][i - 'a'];
    }
    e[u]++;
}

queue<int> q;

void build() {
    for (int i = 0; i < 26; i++) {
        if (tr[0][i]) q.emplace(tr[0][i]);
    }
    while (!q.empty()) {
        int u = q.front();
        q.pop();
        for (int i = 0; i < 26; i++) {
            if (tr[u][i]) {
                fail[tr[u][i]] = tr[fail[u]][i];
                q.emplace(tr[u][i]);
            } else {
                tr[u][i] = tr[fail[u]][i];
            }
        }
    }
}
int query(string t) {
	int u = 0, res = 0;
	for(char i : t) {
		u = tr[u][i - 'a'];
		for(int j = u; j && e[j] != -1; j = fail[j]) {
			res += e[j];
			e[j] = -1;
		}
	}
	return res;
}
}  // namespace AC
```



* 输出出现最多的模式串及其次数

```c++
namespace AC {


int tr[SZ][26], tot;
int e[SZ], fail[SZ];
int val[SZ], idx[SZ];
int cnt[N];

void init() {
    memset(fail, 0, sizeof(fail));
    memset(tr, 0, sizeof(tr));
    memset(val, 0, sizeof(val));
    memset(cnt, 0, sizeof(cnt));
    memset(idx, 0, sizeof(idx));
    tot = 0;
}

void insert(string s, int id) {
    int u = 0;
    for (char i : s) {
        if (!tr[u][i - 'a']) tr[u][i - 'a'] = ++tot;
        u = tr[u][i - 'a'];
    }
    idx[u] = id;
}

queue<int> q;

void build() {
    for (int i = 0; i < 26; i++) {
        if (tr[0][i]) q.emplace(tr[0][i]);
    }
    while (!q.empty()) {
        int u = q.front();
        q.pop();
        for (int i = 0; i < 26; i++) {
            if (tr[u][i]) {
                fail[tr[u][i]] = tr[fail[u]][i];
                q.emplace(tr[u][i]);
            } else {
                tr[u][i] = tr[fail[u]][i];
            }
        }
    }
}
int query(string t) {
    int u = 0, res = 0;
    for (char i : t) {
        u = tr[u][i - 'a'];
        for (int j = u; j && e[j] != -1; j = fail[j]) {
            val[j]++;
        }
    }
    for (int i = 0; i <= tot; i++) {
        if (idx[i]) {
            res = max(res, val[i]);
            cnt[idx[i]] = val[i];
        }
    }
    return res;
}
}  // namespace AC
```



* 数据加强输出所有

```c++
#include <deque>
#include <iostream>

void promote() {
  std::ios::sync_with_stdio(0);
  std::cin.tie(0);
  std::cout.tie(0);
  return;
}

typedef char chr;
typedef std::deque<int> dic;

const int maxN = 2e5;
const int maxS = 2e5;
const int maxT = 2e6;

int n;
chr s[maxS + 10];
chr t[maxT + 10];
int cnt[maxN + 10];

struct AhoCorasickAutomaton {
  struct Node {
    int son[30];
    int val;
    int fail;
    int head;
    dic index;
  } node[maxS + 10];

  struct Edge {
    int head;
    int next;
  } edge[maxS + 10];

  int root;
  int ncnt;
  int ecnt;

  void Insert(chr *str, int i) {
    int u = root;
    for (int i = 1; str[i]; i++) {
      if (node[u].son[str[i] - 'a' + 1] == 0)
        node[u].son[str[i] - 'a' + 1] = ++ncnt;
      u = node[u].son[str[i] - 'a' + 1];
    }
    node[u].index.push_back(i);
    return;
  }

  void Build() {
    dic q;
    for (int i = 1; i <= 26; i++)
      if (node[root].son[i]) q.push_back(node[root].son[i]);
    while (!q.empty()) {
      int u = q.front();
      q.pop_front();
      for (int i = 1; i <= 26; i++) {
        if (node[u].son[i]) {
          node[node[u].son[i]].fail = node[node[u].fail].son[i];
          q.push_back(node[u].son[i]);
        } else {
          node[u].son[i] = node[node[u].fail].son[i];
        }
      }
    }
    return;
  }

  void Query(chr *str) {
    int u = root;
    for (int i = 1; str[i]; i++) {
      u = node[u].son[str[i] - 'a' + 1];
      node[u].val++;
    }
    return;
  }

  void addEdge(int tail, int head) {
    ecnt++;
    edge[ecnt].head = head;
    edge[ecnt].next = node[tail].head;
    node[tail].head = ecnt;
    return;
  }

  void DFS(int u) {
    for (int e = node[u].head; e; e = edge[e].next) {
      int v = edge[e].head;
      DFS(v);
      node[u].val += node[v].val;
    }
    for (auto i : node[u].index) cnt[i] += node[u].val;
    return;
  }

  void FailTree() {
    for (int u = 1; u <= ncnt; u++) addEdge(node[u].fail, u);
    DFS(root);
    return;
  }
} ACM;

int main() {
  std::cin >> n;
  for (int i = 1; i <= n; i++) {
    std::cin >> (s + 1);
    ACM.Insert(s, i);
  }
  ACM.Build();
  std::cin >> (t + 1);
  ACM.Query(t);
  ACM.FailTree();
  for (int i = 1; i <= n; i++) std::cout << cnt[i] << '\n';
  return 0;
}
```

  

### 后缀数组

```c++
namespace SA {
vector<int> sa, rk, oldrk, id, key1, cnt;
int n, m;
void init(string &s) {
    s = " " + s;
    n = s.size() - 1, m = 127;
    sa.resize(n + 1), key1.resize(n + 1), id.resize(n + 1);
    rk.resize((n + 1) << 1), oldrk.resize((n + 1) << 1);
    cnt.resize(max(m, n + 1));
}
void Solve(string s) {
    for (int i = 1; i <= n; i++) ++cnt[rk[i] = s[i]];
    for (int i = 1; i <= m; i++) cnt[i] += cnt[i - 1];
    for (int i = n; i; i--) sa[cnt[rk[i]]--] = i;
    function<bool(int, int, int)> cmp = [&](int x, int y, int w) {
        return oldrk[x] == oldrk[y] && oldrk[x + w] == oldrk[y + w];
    };

    int p;

    for (int w = 1;; w <<= 1, m = p) {
        p = 0;
        for (int i = n; i > n - w; i--) {
            id[++p] = i;
        }
        for (int i = 1; i <= n; i++) {
            if (sa[i] > w) id[++p] = sa[i] - w;
        }
        fill(cnt.begin(), cnt.end(), 0);

        for (int i = 1; i <= n; i++) ++cnt[key1[i] = rk[id[i]]];
        for (int i = 1; i <= m; i++) cnt[i] += cnt[i - 1];
        for (int i = n; i; i--) sa[cnt[key1[i]]--] = id[i];
        oldrk = rk, p = 0;
        for (int i = 1; i <= n; i++) {
            rk[sa[i]] = cmp(sa[i], sa[i - 1], w) ? p : ++p;
        }
        if (p == n) break;
    }
}
};  // namespace SA
```



后缀自动机

```C++
struct SAM {
    static constexpr int ALPHABET_SIZE = 26;
    struct Node {
        int len;
        int link;
        std::array<int, ALPHABET_SIZE> next;
        Node() : len{}, link{}, next{} {}
    };
    std::vector<Node> t;
    SAM() {
        init();
    }
    void init() {
        t.assign(2, Node());
        t[0].next.fill(1);
        t[0].len = -1;
    }
    int newNode() {
        t.emplace_back();
        return t.size() - 1;
    }
    int extend(int p, int c) {
        if (t[p].next[c]) {
            int q = t[p].next[c];
            if (t[q].len == t[p].len + 1) {
                return q;
            }
            int r = newNode();
            t[r].len = t[p].len + 1;
            t[r].link = t[q].link;
            t[r].next = t[q].next;
            t[q].link = r;
            while (t[p].next[c] == q) {
                t[p].next[c] = r;
                p = t[p].link;
            }
            return r;
        }
        int cur = newNode();
        t[cur].len = t[p].len + 1;
        while (!t[p].next[c]) {
            t[p].next[c] = cur;
            p = t[p].link;
        }
        t[cur].link = extend(p, c);
        return cur;
    }
};
```



### Lyndon 分解

```c++
// duval_algorithm
vector<string> duval(string const& s) {
    int n = s.size(), i = 0;
    vector<string> factorization;
    while (i < n) {
        int j = i + 1, k = i;
        while (j < n && s[k] <= s[j]) {
            if (s[k] < s[j]) {
                k = i;
            } else {
                k++;
            }
            j++;
        }
        while (i <= k) {
            factorization.push_back(s.substr(i, j - k));
            i += j - k;
        }
    }
    return factorization;
}
```





### 最小表示法（基于Lyndon)

```c++
// Problem: P1368 【模板】最小表示法
// URL: https://www.luogu.com.cn/problem/P1368
string min_cyclic(string s) {
    s += s;
    int n = s.size();
    int i = 0, ans = 0;
    while (i < n / 2) {
        ans = i;
        int j = i + 1, k = i;
        while (j < n && s[k] <= s[j]) {
            if (s[k] < s[j]) {
                k = i;
            } else {
                k++;
            }
            j++;
        }
        while (i <= k) i += j - k;
    }
    return s.substr(ans, n / 2);
}

```





## 并查集

d[u]表示该点到p[u]的距离




### 朴素并查集


```c++
struct DSU {
    vector<int> p, siz;
    DSU() {}
    DSU(int n) { init(n + 1); }

    void init(int n) {
        p.resize(n);
        iota(p.begin(), p.end(), 0);
        siz.assign(n, 1);
    }

    int find(int u) {
        while (u != p[u]) {
            u = p[u] = p[p[u]];
        }
        return u;
    }

    bool same(int a, int b) { return find(a) == find(b); }

    bool merge(int a, int b) {
        a = find(a);
        b = find(b);
        if (a == b) return false;
        siz[a] += siz[b];
        p[b] = a;
        return true;
    }
    int size(int x) { return siz[find(x)]; }
};
```

### 维护距离的并查集
查找
```c++
int find(int u) {
	if(p[u] != u) {
		int v = find(p[u]);
		d[u] += d[p[u]];
		p[u] = v;
	}
	return p[u];
}
```
合并
```c++
p[find(a)] = find(b);
d[find(a)] = distance;        
```

## 树状数组

### 基础函数

```c++
struct BItree {
    int tr[N], a[N];
    inline int lowbit(int x) { return x & -x; }

    void add(int x, int c) {
        for (; x <= n; x += lowbit(x)) {
            tr[x] += c;
        }
    }
    int sum(int x) {
        int res = 0;
        for (; x; x -= lowbit(x)) {
            res += tr[x];
        }
        return res;
    }
};
```

### 初始化
O(n log n)
```c++
for(int i = 1; i <= n; i++) add(i,a[i]);
```
O(n)

```c++
int s[N]; // a[]的前缀和数组
for(int i = 1; i <= n; i++) c[i] = s[i] - s[x - lowbit(x)];
```

## 线段树

### 单点修改

```C++
// 单点修改
struct SegmentTree {
    int a[N];
    struct {
        int l, r;
        int dat;
    } t[N * 4];
    // build(1, 1, n);
    void build(int p, int l, int r) {
        t[p].l = l, t[p].r = r;
        if (l == r) {
            t[p].dat = a[l];
            return;
        }
        int mid = (l + r) / 2;
        build(p * 2, l, mid);
        build(p * 2 + 1, mid + 1, r);
        t[p].dat = max(t[p * 2].dat, t[p * 2 + 1].dat);
    }
    // 单点修改
    void change(int p, int x, int v) {
        if (t[p].r == t[p].l) {
            t[p].dat = v;
            return;
        }
        int mid = (t[p].r + t[p].l) / 2;
        if (x <= mid)
            change(p * 2, x, v);
        else
            change(p * 2 + 1, x, v);
        t[p].dat = max(t[p * 2].dat, t[p * 2 + 1].dat);
    }
    // ask(1, l, r) 区间查询
    int ask(int p, int l, int r) {
        if (l <= t[p].l && r >= t[p].r) {
            return t[p].dat;
        }
        int mid = (t[p].l + t[p].r) / 2;
        int val = -INF;
        if (l <= mid) val = max(val, ask(p * 2, l, r));
        if (r > mid) val = max(val, ask(p * 2 + 1, l, r));
        return val;
    }
};

```

### 区间加

```C++
// 区间加
#define l(x) tr[x].l
#define r(x) tr[x].r
#define sum(x) tr[x].sum
#define add(x) tr[x].add
struct SegmentTree {
    int a[N];
    struct {
        int l, r;
        long long add, sum;

    } tr[N * 4];
    // build(1, 1, n);
    void build(int p, int l, int r) {
        l(p) = l, r(p) = r;
        if (l == r) {
            sum(p) = a[l];
            return;
        }
        int mid = (l + r) / 2;
        build(p * 2, l, mid);
        build(p * 2 + 1, mid + 1, r);
        sum(p) = sum(p * 2) + sum(p * 2 + 1);
    }

    void spread(int p) {
        if (add(p)) {
            sum(p * 2) += add(p) * (r(p * 2) - l(p * 2) + 1);
            sum(p * 2 + 1) += add(p) * (r(p * 2 + 1) - l(p * 2 + 1) + 1);
            add(p * 2) += add(p);
            add(p * 2 + 1) += add(p);
            add(p) = 0;
        }
    }

    // 区间加
    void change(int p, int l, int r, int d) {
        if (l <= l(p) && r >= r(p)) {
            sum(p) += (long long)d * (r(p) - l(p) + 1);
            add(p) += d;
            return;
        }
        spread(p);
        int mid = (l(p) + r(p)) / 2;
        if (l <= mid) change(p * 2, l, r, d);
        if (r > mid) change(p * 2 + 1, l, r, d);
        sum(p) = sum(p * 2) + sum(p * 2 + 1);
    }
    // ask(1, l, r) 区间查询
    long long ask(int p, int l, int r) {
        if (l <= l(p) && r >= r(p)) {
            return sum(p);
        }
        spread(p);
        int mid = (l(p) + r(p)) / 2;
        int val = 0;
        if (l <= mid) val += ask(p * 2, l, r);
        if (r > mid) val += ask(p * 2 + 1, l, r);
        return val;
    }
};
```





## ST表

```c++
template <class T>
struct SparseTable {
    vector<vector<T>> st;
    vector<long long> lg;
    SparseTable(const vector<T>& s) {
        const int N = s.size();
        st.assign(N, vector<T>(21, 0));
        lg.resize(N);
        for (int i = 2; i < N; i++) lg[i] = lg[i >> 1] + 1;
        for (int i = 1; i < N; ++i) st[i][0] = s[i];
        for (int j = 1; j <= lg[N - 1]; j++) {
            for (int i = 1; i + (1 << j) - 1 < N; i++) {
                st[i][j] = max(st[i][j - 1], st[i + (1 << (j - 1))][j - 1]);
            }
        }
    }
    T query(int L, int R) {
        int k = lg[R - L + 1];
        return max(st[L][k], st[R - (1 << k) + 1][k]);
    }
};

SparseTable<int> ST(v);
```



# 图论算法

## 最短路算法

### Dijkstar

```c++
int dist[N];
bool vis[N];
int dijkstra() {
    memset(dist,0x3f,sizeof dist);
    dist[1] = 0;
    priority_queue<pii,vector<pii>,greater<pii>> q;
    q.emplace(0,1);
    
    while(q.size()) {
        auto t = q.top();
        q.pop();
        int u = t.second,d1 = t.first;
        if(vis[u]) continue;
        vis[u] = true;
        
        for(auto i : g[u]) {
            int v = i.first, d2 = i.second;
            if(dist[v] > d1 + d2) {
                dist[v] = d1 + d2;
                q.emplace(dist[v], v);
            }
        }
    }
    if(dist[n] == 0x3f3f3f3f) return -1;
    else return dist[n];
}
```
### bellman_ford
```c++
const int M = ,N = ;
int n,m,k; //n个点，m条边，最多走k条边
struct Edge {
    int a,b,w;
}edges[M];
int dist[N],lastest[N];

void bellman_ford() {
    memset(dist,0x3f,sizeof dist);
    dist[1] = 0;
    for(int i = 0; i < k; i++) {
        memcpy(lastest,dist,sizeof dist);
        for(int j = 0; j < m; j++) {
            auto e = edges[j];
            dist[e.b] = min(dist[e.b],lastest[e.a] + e.w);
        }
    }
}
```
### SPFA算法

#### 求最短路

```c++
queue<int> q;
bool vis[N];
int dist[N];
void spfa() {
    vis[1] = 1;
    dist[1] = 1;
    q.emplace(1);
    while (q.size()) {
        int u = q.front();
        q.pop();
        vis[u] = false;
        for (auto i : g[u]) {
            int v = i.first, w = i.second;
            if (dist[v] > dist[u] + w) {
                dist[v] = dist[u] + w;
                if (!vis[v]) {
                    vis[v] = true;
                    q.emplace(v);
                }
            }
        }
    }
}

```
#### 判断负环
```
bool vis[N];
int dist[N], cnt[N];
bool spfa() {
    queue<int> q;
    for (int i = 1; i <= n; i++) {
        q.push(i);
        vis[i] = true;
    }
    while (q.size()) {
        int u = q.front();
        q.pop();
        vis[u] = false;

        for (auto i : g[u]) {
            int w = i.second, v = i.first;
            if (dist[v] > dist[u] + w) {
                dist[v] = dist[u] + w;
                cnt[v] = cnt[u] + 1;
                if (cnt[v] >= n) return true;
                if (!vis[v]) {
                    q.push(v);
                    vis[v] = true;
                }
            }
        }
    }
    return false;
}
```
### Floyd
```c++
void floyd() {
	for(int k = 1; k <= n; k++) {
		for(int i = 1; i <= n; i++) {
			for(int j = 1; j <= n; j++) {
				dp[i][j] = min(dp[i][j],dp[i][k] + dp[k][j]);
			}
		}
	}
}
```

## 拓扑排序
```c++
int top[N], d[N], cnt = 0;
int n, m;
vector<int> g[N];
bool topsort() {
    queue<int> q;
    for(int i = 1; i <= n; i++) {
        if(d[i] == 0) q.push(i);
    }
    while(q.size()) {
        int t = q.front();
        top[cnt++] = t;
        q.pop();
        for(int i : g[t]) {
            d[i]--;
            if(d[i] == 0) q.push(i);
        }
    }
    return cnt == n;
}
```
## 最小生成树
### prim


适用于稠密图

```c++
int m,n,g[N][N],dist[N],st[N];

int prim() {
    memset(dist,0x3f,sizeof dist) ;

    int res = 0;
    for(int i = 0;i < n; i++) {
        int t = -1;
        for(int j = 1; j <= n; j++) {
            if(!st[j] && (t == -1 || dist[t] > dist[j])) 
                t = j;
        }
        if(i && dist[t] == INF) return INF;      //表示最小生成树不存在
        if(i) res += dist[t];
        st[t] = 1;
        for(int j = 1; j <= n; j++) dist[j] = min(dist[j],g[t][j]);
    }
    return res;
}
```
### kruskal

适用于稀疏图

```c++
struct edge {
    int a, b, w;
    bool operator<(const edge &W) const {
        if (w != W.w) return w < W.w;
        else if(a != W.a) return a < W.a;
        else return b < W.b;
    }
};
vector<edge> edges;

int p[N];
//并查集
int find(int x) {
    if (p[x] != x) p[x] = find(p[x]);
    return p[x];
}
//最小生成树算法
int kruskal(int n) {
    sort(edges.begin(), edges.end());
    int res = 0, cnt = 0;
    for (auto [a, b, w] : edges) {
        int fa = find(a), fb = find(b);
        if (fa != fb) {
            p[fa] = fb;
            res += w;
            cnt++;
        }
    }
    if (cnt < n - 1) return INF;  //表示最小生成树不存在
    return res;
}
```
## LCA

### 倍增

```c++
const int LG = 24;
vector<int> g[N];
int dep[N], fa[N][LG + 5];
void bfs(int root) {
    memset(dep, 0x3f, sizeof dep);
    dep[0] = 0, dep[root] = 1;
    queue<int> q;
    q.emplace(root);
    while (q.size()) {
        int u = q.front();
        q.pop();
        for (auto v : g[u]) {
            if (dep[v] > dep[u] + 1) {
                dep[v] = dep[u] + 1;
                q.emplace(v);
                fa[v][0] = u;
                for (int j = 1; j <= LG; j++) {
                    fa[v][j] = fa[fa[v][j - 1]][j - 1];
                }
            }
        }
    }
}

int lca(int a, int b) {
    if (dep[a] < dep[b]) swap(a, b);

    for (int k = LG; k >= 0; k--) {
        if (dep[fa[a][k]] >= dep[b]) {
            a = fa[a][k];
        }
    }

    if (a == b) return a;

    for (int k = LG; k >= 0; k--) {
        if (fa[a][k] != fa[b][k]) {
            a = fa[a][k];
            b = fa[b][k];
        }
    }
    return fa[a][0];
}
```



### tarjan

```
vector<pii> g[N], query[N];
int dist[N], ans[M], p[N], st[N];

void dfs(int u, int fa) {
	for(int i = 0; i < g[u].size(); i++) {
		int v = g[u][i].fi, w = g[u][i].se;
		if(v == fa) continue;
		dist[v] = dist[u] + w;
		dfs(v, u);
	}
}

int findset(int x) {
	if(p[x] != x) return findset(p[x]);
	else return p[x];
}

void tanjar(int u) {
	st[u] = 1;
	for(int i = 0; i < g[u].size(); i++) {
		int v = g[u][i].fi;
		if(!st[v]) {
			tanjar(v);
			p[v] = u;
		}
	}
	for(int i = 0; i < query[u].size(); i++) {
		int id = query[u][i].se, v = query[u][i].fi;
		if(st[v] == 2) {
			int anc = findset(v);
			ans[id] = dist[u] + dist[v] - dist[anc] * 2;
		}
	}
	st[u] = 2;
}

signed main() {
	int n, m; cin >> n >> m;
	for(int i = 1; i < n; i++) {
		int x, y, k; 
		cin >> x >> y >> k;
		g[x].pb({y, k});
		g[y].pb({x, k});
	}
	for(int i = 0; i <= n; i++) p[i] = i;
	for(int i = 0; i < m; i++) {
		int a, b; cin >> a >> b;
		if(a != b) {
			query[a].pb({b, i});
			query[b].pb({a, i});			
		}
	}
	
	dfs(1, -1); 
	tanjar(1);
	for(int i = 0; i < m; i++) cout << ans[i] << endl;
	
}
```

### 树上前缀和

在预处理中

```c++
for (int i = 1; i <= LG; i++) {
        f[u][i] = f[f[u][i - 1]][i - 1];
        d[u][i] = d[f[u][i - 1]][i - 1] + d[u][i - 1];
}
```

计算

```C++
int lca(int a, int b) {
    if (dep[a] < dep[b]) swap(a, b);

    int res = 0;
    for (int k = LG; k >= 0; k--) {
        if (dep[fa[a][k]] >= dep[b]) {
            res += d[a][k];
            a = fa[a][k];
        }
    }

    if (a == b) return res + d[a][0];
    // 计算祖宗节点
    // if (a == b) return res + d[a][0];
    for (int k = LG; k >= 0; k--) {
        if (fa[a][k] != fa[b][k]) {
            res += d[a][k] + d[b][k];
            a = fa[a][k], b = fa[b][k];
        }
    }
    res += d[a][0] + d[b][0];
    // 计算祖宗节点
    // res += d[fa[a][0]][0]
    return res;
}
```



### 树上差分

区间操作

```
for (int i = 1; i <= m; i++) {
    cin >> a >> b;
    cin >> wa >> wb;
    w[a]+= wa, w[b]+= wb;
    w[lca(a, b)] -= (wa + wb);
}
vis[root] = true;
dfs(root);
```

前缀操作

```c++
void dfs(int u) {
    for (auto v : g[u]) {
        if (vis[v]) continue;
        vis[v] = true;
        dfs(v);
        w[u] += w[v];
    }
}
```

## 连通性

### 割点与桥

无向图割点

```c++
int to[M], idx;
vector<int> g[N];
int dfn[N], low[N];
int num, ans, root;
bool cut[N];

void add(int u, int v) {
    g[u].push_back(idx);
    to[idx++] = v;
    g[v].push_back(idx);
    to[idx++] = u;
}

void tarjan(int u) {
    low[u] = dfn[u] = ++num;
    int child = 0;
    for (auto i : g[u]) {
        int v = to[i];
        if (!dfn[v]) {
            tarjan(v);
            low[u] = min(low[u], low[v]);
            if (low[v] >= dfn[u]) {
                child++;
                if (u != root || child > 1) {
                    if (!cut[u]) {
                        ans++;
                        cut[u] = true;
                    }
                }
            }
        } else
            low[u] = min(low[u], dfn[v]);
    }
}
```

无向图割边

```c++
// Problem: T103481 【模板】割边
// URL: https://www.luogu.com.cn/problem/T103481

int dfn[N], low[N], num;
vector<int> g[N];
int idx, to[M << 1];
bool bridge[M << 1];
void add(int u, int v) {
    g[u].push_back(idx);
    to[idx++] = v;
    g[v].push_back(idx);
    to[idx++] = u;
}
int ans, n, m;
void tarjan(int u, int edge) {
	dfn[u] = low[u] = ++num;
	for(auto i : g[u]) {
		int v = to[i];
		if(!dfn[v]) {
			tarjan(v, i);
			low[u] = min(low[u], low[v]);
			if(low[v] > dfn[u]) {
				ans++;
				bridge[i] = bridge[i ^ 1] = true;
			}
		} else if(i != (edge ^ 1)) {
			low[u] = min(low[u], dfn[v]);
		}
	}
}

```

### 双连通分量

* 边双连通分量

```c++
// 割边模板 此处省略
vector<vector<int>> ans;

int c[N], dcc;
void dfs(int u) {
    c[u] = dcc;
    ans[dcc - 1].emplace_back(u);
    for (int i : g[u]) {
        int v = to[i];
        if (c[v] || bridge[i]) continue;
        dfs(v);
    }
}

signed main() {
    cin >> n >> m;
    for (int i = 1, u, v; i <= m; i++) {
        cin >> u >> v;
        if (u == v) continue;
        add(u, v);
    }

    for (int i = 1; i <= n; i++) {
        if (!dfn[i]) tarjan(i, 0);
    }
    for (int i = 1; i <= n; i++) {
        if (!c[i]) {
            ++dcc;
            // cerr << i << endl;
            ans.push_back(vector<int>());
            dfs(i);
        }
    }

    cout << dcc;

    for (int i = 0; i < dcc; i++) {
        cout << "\n" << ans[i].size();
        for (int j : ans[i]) {
            cout << " " << j;
        }
    }
    return 0;
}
```



* 点双连通分量

```c++
int low[N], dfn[N], num;
vector<int> g[N];
int to[M], idx;

void add(int u, int v) {
    g[u].push_back(idx);
    to[idx++] = v;
    g[v].push_back(idx);
    to[idx++] = u;
}
vector<int> dcc[N];
int cnt = 0;
int cut[N];
int sta[N], tp, root;
void tarjan(int u) {
    low[u] = dfn[u] = ++num;
    sta[++tp] = u;
    if (u == root && g[u].empty()) {
        dcc[++cnt].emplace_back(u);
        return;
    }
    int flag = 0;
    for(int i : g[u]) {
    	int v = to[i];
    	if(!dfn[v]) {
    		tarjan(v);
    		low[u] = min(low[u], low[v]);
    		if(low[v] >= dfn[u]) {
    			flag ++;
    			if(u != root || flag  > 1) cut[u]  =  true;
    			cnt++;
    			int z;
    			do {
    				z = sta[tp--];
    				dcc[cnt].push_back(z);
    			} while(z != v);
    			dcc[cnt].emplace_back(u);
    		}
    	} else low[u] = min(low[u], dfn[v]);
    }
}

int n, m;

signed main() {
    cin >> n >> m;
    for (int i = 1, u, v; i <= m; i++) {
        cin >> u >> v;
        if (u == v) continue;
        add(u, v);
    }
    for (int i = 1; i <= n; i++) {
        if (!dfn[i]) {
            root = i;
            tarjan(i);
        }
    }
    cout << cnt << endl;
    for(int i = 1; i <= cnt; i++) {
    	cout << dcc[i].size() << ' ';
    	for(int j : dcc[i]) {
    		cout << j << ' ';
    	}
    	cout << endl;
    }
    return 0;
}
```





### 强连通分量

```c++
int low[N], dfn[N], sz[N], s[N], scc[N];
int dfncnt, sc, tp;
bool in_stack[N];
void tarjan(int u) {
    low[u] = dfn[u] = ++dfncnt;
    s[++tp] = u, in_stack[u] = 1;
    for (int v : g[u]) {
        if (!dfn[v]) {
            tarjan(v);
            low[u] = min(low[u], low[v]);
        } else if (in_stack[v]) {
            low[u] = min(low[u], dfn[v]);
        }
    }
    if (dfn[u] == low[u]) {
        scc[u] = ++sc;
        sz[sc]++;
        while (s[tp] != u) {
            scc[s[tp]] = sc;
            sz[sc]++;
            in_stack[s[tp]] = 0;
            --tp;
        }
        in_stack[s[tp]] = 0;
        --tp;
    }
}
```





## 二分图

### 染色法判断二分图

```c++
bool dfs(int u, int v) {
    color[u] = v;
    for (auto i : g[u]) {
        if (!color[i]) {
            if (!dfs(i, 3 - v)) return false;
        } else if (color[i] == v) {
            return false;
        }
    }
    return true;
}
bool check() {
    for (int i = 1; i <= n; i++) {
        if (!color[i]) {
            if (!dfs(i, 1)) {
                return false;
            }
        }
    }
    return true;
}
```

### 二分图最大匹配（匈牙利算法）

```c++
bool Match(int u) {
	for(auto v : g[u]) {
		if(vis[v]) continue;
		vis[v] = true;
		if(match[v] == 0 || Match(match[v])) {
			match[v] = u;
			return true;
		}
	}
	return false;
}
int res() {
	int ans = 0;
	for(int i = 1; i <= n1; i++) {
    	memset(st,0 ,sizeof st);
    	if(Match(i)) ans++;
    }
    return ans;
}
```



## 网络流

### 最大流

dinic

```c++

struct Edge {
    int to;
    long long w;
} e[M << 1];
vector<int> g[N];
int now[N], d[N];
int n, m, s, t, idx;
long long maxflow;
queue<int> q;


void init(int n) {
    for (int i = 0; i <= 2 * n + 5; i++) {
        g[i].clear();
        now[i] = 0;
    }
    memset(e, 0, sizeof e);
    idx = maxflow = 0;
}

void add(int u, int v, int w, int c = 0) {
    g[u].push_back(idx);
    e[idx++] = {v, w};

    g[v].push_back(idx);
    e[idx++] = {u, c};
}

bool bfs() {
    memset(d, 0, sizeof d);
    while (q.size()) q.pop();
    q.push(s);
    d[s] = 1, now[s] = 0;
    while (q.size()) {
        int u = q.front();
        q.pop();
        for (int v : g[u]) {
            if (e[v].w && !d[e[v].to]) {
                q.push(e[v].to);
                now[e[v].to] = 0;
                d[e[v].to] = d[u] + 1;
                if (e[v].to == t) return true;
            }
        }
    }
    return false;
}

long long dinic(int u, long long flow) {
    if (u == t) return flow;
    long long rest = flow, k, i;
    for (i = now[u]; i < g[u].size(); i++) {
        int v = g[u][i];
        if (e[v].w && d[e[v].to] == d[u] + 1) {
            k = dinic(e[v].to, min(rest, e[v].w));
            if (k == 0) d[e[v].to] = 0;
            e[v].w -= k, e[v ^ 1].w += k;
            rest -= k;
        }
    }
    now[u] = i;
    return flow - rest;
}
signed main() {
    ...
    long long flow = 0;
    while (bfs()) {
        while (flow = dinic(s, INF)) maxflow += flow;
    }
    cout << maxflow << endl;
    return 0;
}
```

### 费用流

```c++
struct edge {
    int v, f, c;
} e[M * 2];

struct node {
    int v, e;
} p[N];

vector<int> g[N];
int dis[N], vis[N], h[N], idx;
int n, m, s, t;

void add(int u, int v, int f, int c) {
    g[u].push_back(idx);
    e[idx++] = {v, f, c};

    g[v].push_back(idx);
    e[idx++] = {u, 0, -c};
}

bool dijkstra() {
    priority_queue<pii, vector<pii>, greater<pii> > q;
    memset(dis, 0x3f, sizeof dis);
    memset(vis, 0, sizeof vis);
    dis[s] = 0;
    q.emplace(0, s);
    while (!q.empty()) {
        int u = q.top().second;
        q.pop();
        if (vis[u]) continue;
        vis[u] = 1;
        for (int i : g[u]) {
            int v = e[i].v, nc = e[i].c + h[u] - h[v];
            if (e[i].f && dis[v] > dis[u] + nc) {
                dis[v] = dis[u] + nc;
                p[v] = {u, i};
                if (!vis[v]) q.emplace(dis[v], v);
            }
        }
    }
    return dis[t] != INF;
}

void spfa() {
    queue<int> q;
    memset(h, 0x3f, sizeof h);
    h[s] = 0, vis[s] = 1;
    q.push(s);
    while (!q.empty()) {
        int u = q.front();
        q.pop();
        vis[u] = 0;
        for (int i : g[u]) {
            int v = e[i].v;
            if (e[i].f && h[v] > h[u] + e[i].c) {
                h[v] = h[u] + e[i].c;
                if (!vis[v]) {
                    vis[v] = 1;
                    q.push(v);
                }
            }
        }
    }
}
int maxf, mc;

void MCMF() {
    spfa();
    while (dijkstra()) {
        int flow = INF;
        for (int i = 0; i <= n + 5; i++) h[i] += dis[i];
        for (int i = t; i != s; i = p[i].v) flow = min(flow, e[p[i].e].f);
        for (int i = t; i != s; i = p[i].v) {
            e[p[i].e].f -= flow;
            e[p[i].e ^ 1].f += flow;
        }
        maxf += flow;
        mc += flow * h[t];
    }
}

```



最大费用

```c++
// URL: https://www.luogu.com.cn/problem/P4015

#include <bits/stdc++.h>
using namespace std;

typedef long long ll;
typedef pair<int, int> pii;
const int mod = 1e9 + 7, INF = 0x3f3f3f3f;
const int N = 1e3 + 10, M = 2e3 + 10;

int n, m, s, t;

namespace MaxMCMF {
// 内容同上 此处省略
}  // namespace MaxMCMF

ll a[N], b[N], c[N][N];
void solve() {
    cin >> m >> n;
    s = 0, t = n + m + 1;
    ll sf = 0, mxd = 0;

    for (int i = 1; i <= m; i++) {
        cin >> a[i];
        MaxMCMF::add(s, i, a[i], 0);
        sf += a[i];
    }
    for (int i = 1; i <= n; i++) {
        cin >> b[i];
        MaxMCMF::add(i + m, t, b[i], 0);
    }
    for (int i = 1; i <= m; i++) {
        for (int j = 1; j <= n; j++) {
            cin >> c[i][j];
            mxd = max(mxd, c[i][j]);
        }
    }
    for (int i = 1; i <= m; i++) {
        for (int j = 1; j <= n; j++) {
            cin >> c[i][j];
            MaxMCMF::add(i, j + m, INF, mxd - c[i][j]);
        }
    }
    
    MaxMCMF::MCMF();
	
    cout << -(MaxMCMF::mc - mxd * sf) << endl;
}


```



## 差分约束

```c++
// Problem: P4926 [1007]倍杀测量者
// Contest: Luogu
// URL: https://www.luogu.com.cn/problem/P4926


#include <bits/stdc++.h>
// #pragma GCC optimize(1)
// #pragma GCC optimize(2)
// #pragma GCC optimize(3, "Ofast", "inline")
using namespace std;
#define IOS ios::sync_with_stdio(false), cin.tie(0), cout.tie(0)
#define fi first
#define se second
#define endl '\n'
#define YES cout << "YES\n"
#define NO cout << "NO\n"
#define Yes cout << "Yes\n"
#define No cout << "No\n"
typedef long long ll;
typedef pair<int, int> pii;
typedef pair<int, double> pid;

const int mod = 1e9 + 7, INF = 0x3f3f3f3f;
const int N = 1e3 + 10;
// #define int long long

int score[N];
double dist[N];
bool vis[N];
int n, s;
struct T {
    int v, o;
    double k, w;
};
vector<T> g[N];
int cnt[N];

bool spfa(double t) {
    for (int i = 0; i <= n; i++) {
        dist[i] = -INF;
        vis[i] = 0;
        cnt[i] = 0;
    }
    queue<int> q;
    q.push(n + 1);
    vis[n + 1] = true;
    dist[n + 1] = 0;
    cnt[n + 1]++;
    while (!q.empty()) {
        int u = q.front();
        vis[u] = false;
        q.pop();
        for (auto i : g[u]) {
            double w, k = i.k;
            int v = i.v, o = i.o;
            if (o == 0) w = i.w;
            if (o == 1) w = log2(k - t);
            if (o == 2) w = -log2(k + t);
            if (dist[v] < dist[u] + w) {
                dist[v] = dist[u] + w;
                if (!vis[v]) {
                    cnt[v]++;
                    vis[v] = true;
                    q.push(v);
                    if (cnt[v] >= n + 1) return false;
                }
            }
        }
    }
    return true;
}

signed main() {
    int t;
    cin >> n >> s >> t;
    double l = 0, r = 10;
    for (int i = 1; i <= s; i++) {
        int o, a, b;
        double k;
        cin >> o >> a >> b >> k;
        g[b].push_back({a, o, k, 0});
        if (o == 1) r = min(r, k);
    }

    for (int i = 1, c; i <= t; i++) {
        double x;
        cin >> c >> x;
        g[0].push_back({c, 0, 0, log2(x)});
        g[c].push_back({0, 0, 0, -log2(x)});
    }

    for (int i = 0; i <= n; i++) g[n + 1].push_back({i, 0, 0, 0});

    if (spfa(0)) {
        cout << -1;
        return 0;
    }
    while (r - l > 1e-5) {
        double mid = (l + r) / 2;
        if (spfa(mid))
            r = mid;
        else
            l = mid;
    }
    printf("%.10lf", l);
}
```

## 2-SAT

```c++
// Problem: P4782 【模板】2-SAT 问题
// URL: https://www.luogu.com.cn/problem/P4782

const int N = 4e6 + 10;

int dfn[N], low[N], dfncnt, s[N], tp;
int scc[N], sc;  // 结点 i 所在 SCC 的编号
int sz[N];       // 强连通 i 的大小
bool vis[N];
vector<int> g[N];
void add(int a, int b) { g[a].emplace_back(b); }
void tarjan(int u) {
    low[u] = dfn[u] = ++dfncnt;
    s[++tp] = u, vis[u] = 1;
    for (int v : g[u]) {
        if (!dfn[v]) {
            tarjan(v);
            low[u] = min(low[u], low[v]);
        } else if (vis[v]) {
            low[u] = min(low[u], dfn[v]);
        }
    }
    if (dfn[u] == low[u]) {
        ++sc;
        while (s[tp] != u) {
            scc[s[tp]] = sc;
            sz[sc]++;
            vis[s[tp]] = 0;
            --tp;
        }
        scc[s[tp]] = sc;
        sz[sc]++;
        vis[s[tp]] = 0;
        --tp;
    }
}

signed main() {
    IOS;
    int n, m;
    cin >> n >> m;
    for (int i = 1; i <= m; i++) {
        int a, x, b, y;
        cin >> a >> x >> b >> y;
        if (x == 0 && y == 0) {
            add(a + n, b);
            add(b + n, a);
        } else if (x == 1 && y == 0) {
            add(b + n, a + n);
            add(a, b);
        } else if (x == 0 && y == 1) {
            add(a + n, b + n);
            add(b, a);
        } else {
            add(a, b + n);
            add(b, a + n);
        }
    }
    for (int i = 1; i <= 2 * n; i++) {
        if (!dfn[i]) tarjan(i);
    }
    for (int i = 1; i <= 2 * n; i++) {
        if (scc[i] == scc[i + n]) {
            puts("IMPOSSIBLE\n");
            return 0;
        }
    }
    puts("POSSIBLE");
    for (int i = 1; i <= n; i++) {
        if (scc[i] > scc[i + n]) {
            printf("1 ");
        } else {
            printf("0 ");
        }
    }
    return 0;
}
```





## 同余最短路

```c++
void solve() {
    memset(dist, 0x7f, sizeof dist);
    int h;
    cin >> h;
    int x, y, z;
    cin >> x >> y >> z;
    if (x > y) swap(x, y);
    if (x > z) swap(x, z);
    if (x == 1) {
        cout << h;
        return;
    }
    int Begin = 1;
    // cin >> Begin;
    for (int i = 0; i < x; i++) {
        add(i, (i + y) % x, y);
        add(i, (i + z) % x, z);
    }
    spfa(Begin);
    ll ans = 0;
    
    for (int i = 0; i < x; i++) {
        if (h >= dist[i]) ans += (h - dist[i]) / x + 1;
    }
    cout << ans << endl;
}
```

## 欧拉路径

1. 无向图是欧拉图当且仅当：
   - 非零度顶点是连通的
   - 顶点的度数都是偶数
2. 无向图是半欧拉图当且仅当：
   - 非零度顶点是连通的
   - 恰有 2 个奇度顶点
3. 有向图是欧拉图当且仅当：
   - 非零度顶点是强连通的
   - 每个顶点的入度和出度相等
4. 有向图是半欧拉图当且仅当：
   - 非零度顶点是弱连通的
   - 至多一个顶点的出度与入度之差为 1
   - 至多一个顶点的入度与出度之差为 1
   - 其他顶点的入度和出度相等



## 树哈希

哈希模板

```C++
typedef unsigned long long ull;

const ull mask = std::chrono::steady_clock::now().time_since_epoch().count();

ull shift(ull x) {
    x ^= mask;
    x ^= x << 13;
    x ^= x >> 7;
    x ^= x << 17;
    x ^= mask;
    return x;
}

int n;
ull Hash[N];
std::vector<int> g[N]; // 存边
std::set<ull> trees;

void getHash(int x = 0, int p = 0) {
    Hash[x] = 1;
    for (int i : g[x]) {
        if (i == p) {
            continue;
        }
        getHash(i, x);
        Hash[x] += shift(Hash[i]);
    }
    trees.insert(Hash[x]);
}

void Solve() {
    cin >> n;
    for (int i = 1, u, v; i < n; i++) {
        cin >> u >> v;
        g[u].push_back(v);
        g[v].push_back(u);
    }
    getHash(1, 0);
    cout << trees.size() << endl;
}
```

树同构

```c++
// Problem: P5043 【模板】树同构（[BJOI2015]树的同构）

void getSub(int u) {
    sub[u] = 1;
    for (int v : g[u]) {
        getSub(v);
        sub[u] += shift(sub[v]);
    }
}

void getRoot(int u) {
    for (int v : g[u]) {
        root[v] = sub[v] + shift(root[u] - shift(sub[v]));
        getRoot(v);
    }
}
int cnt = 0;
void Solve() {
    cin >> n;
    cnt++;
    int rt = 0;
    for (int i = 1, u; i <= n; i++) {
        cin >> u;
        if (u) {
            g[u].emplace_back(i);
        } else {
            rt = i;
        }
    }
    getSub(rt);
    root[rt] = sub[rt];
    getRoot(rt);
    ull Hash = 1;
    for (int i = 1; i <= n; i++) {
        Hash += shift(root[i]);
    }
    if (!trees.count(Hash)) {
        trees[Hash] = cnt;
    }
    cout << trees[Hash] << endl;
    Clear(n);
}
```

## KM算法

```C++
template <typename T>
struct hungarian {  // km
    int n;
    vector<int> matchx;  // 左集合对应的匹配点
    vector<int> matchy;  // 右集合对应的匹配点
    vector<int> pre;     // 连接右集合的左点
    vector<bool> visx;   // 拜访数组 左
    vector<bool> visy;   // 拜访数组 右
    vector<T> lx;
    vector<T> ly;
    vector<vector<T> > g;
    vector<T> slack;
    T inf;
    T res;
    queue<int> q;
    int org_n;
    int org_m;

    hungarian(int _n, int _m) {
        org_n = _n;
        org_m = _m;
        n = max(_n, _m);
        inf = numeric_limits<T>::max();
        res = 0;
        g = vector<vector<T> >(n, vector<T>(n));
        matchx = vector<int>(n, -1);
        matchy = vector<int>(n, -1);
        pre = vector<int>(n);
        visx = vector<bool>(n);
        visy = vector<bool>(n);
        lx = vector<T>(n, -inf);
        ly = vector<T>(n);
        slack = vector<T>(n);
    }

    void addEdge(int u, int v, int w) {
        g[u][v] = max(w, 0);  // 负值还不如不匹配 因此设为0不影响
    }

    bool check(int v) {
        visy[v] = true;
        if (matchy[v] != -1) {
            q.push(matchy[v]);
            visx[matchy[v]] = true;  // in S
            return false;
        }
        // 找到新的未匹配点 更新匹配点 pre 数组记录着"非匹配边"上与之相连的点
        while (v != -1) {
            matchy[v] = pre[v];
            swap(v, matchx[pre[v]]);
        }
        return true;
    }

    void bfs(int i) {
        while (!q.empty()) {
            q.pop();
        }
        q.push(i);
        visx[i] = true;
        while (true) {
            while (!q.empty()) {
                int u = q.front();
                q.pop();
                for (int v = 0; v < n; v++) {
                    if (!visy[v]) {
                        T delta = lx[u] + ly[v] - g[u][v];
                        if (slack[v] >= delta) {
                            pre[v] = u;
                            if (delta) {
                                slack[v] = delta;
                            } else if (check(v)) {  // delta=0
                                                    // 代表有机会加入相等子图
                                                    // 找增广路 找到就return
                                                    // 重建交错树
                                return;
                            }
                        }
                    }
                }
            }
            // 没有增广路 修改顶标
            T a = inf;
            for (int j = 0; j < n; j++) {
                if (!visy[j]) {
                    a = min(a, slack[j]);
                }
            }
            for (int j = 0; j < n; j++) {
                if (visx[j]) {  // S
                    lx[j] -= a;
                }
                if (visy[j]) {  // T
                    ly[j] += a;
                } else {  // T'
                    slack[j] -= a;
                }
            }
            for (int j = 0; j < n; j++) {
                if (!visy[j] && slack[j] == 0 && check(j)) {
                    return;
                }
            }
        }
    }

    void solve() {
        // 初始顶标
        for (int i = 0; i < n; i++) {
            for (int j = 0; j < n; j++) {
                lx[i] = max(lx[i], g[i][j]);
            }
        }

        for (int i = 0; i < n; i++) {
            fill(slack.begin(), slack.end(), inf);
            fill(visx.begin(), visx.end(), false);
            fill(visy.begin(), visy.end(), false);
            bfs(i);
        }

        // custom
        for (int i = 0; i < n; i++) {
            if (g[i][matchx[i]] > 0) {
                res += g[i][matchx[i]];
            } else {
                matchx[i] = -1;
            }
        }
        cout << res << "\n";
        for (int i = 0; i < org_n; i++) {
            cout << matchx[i] + 1 << " ";
        }
        cout << "\n";
    }
};

```



最大完美匹配

```c++
// Problem: P6577 【模板】二分图最大权完美匹配
// URL: https://www.luogu.com.cn/problem/P6577

// 2023 XJArsen

#include <bits/stdc++.h>
using namespace std;
using pii = pair<int, int>;
using ll = long long;
const int INF = 0x3f3f3f3f;
const int N = 1e9 + 10;
// #define int long long

template <typename T>
struct hungarian {  // km
    int n;
    vector<int> matchx;  // 左集合对应的匹配点
    vector<int> matchy;  // 右集合对应的匹配点
    vector<int> pre;     // 连接右集合的左点
    vector<bool> visx;   // 拜访数组 左
    vector<bool> visy;   // 拜访数组 右
    vector<T> lx;
    vector<T> ly;
    vector<vector<T> > g;
    vector<T> slack;
    T inf;
    T res;
    queue<int> q;
    int org_n;
    int org_m;
    hungarian() {}
    hungarian(int _n, int _m) {
        org_n = _n;
        org_m = _m;
        n = max(_n, _m);
        inf = 1e14;
        res = 0;
        g = vector<vector<T> >(n, vector<T>(n, -inf));
        matchx = vector<int>(n, -1);
        matchy = vector<int>(n, -1);
        pre = vector<int>(n);
        visx = vector<bool>(n);
        visy = vector<bool>(n);
        lx = vector<T>(n, -inf);
        ly = vector<T>(n);
        slack = vector<T>(n, -inf);
    }

    void addEdge(int u, int v, long long w) { g[u][v] = max(w, g[u][v]); }

    bool check(int v) {
        visy[v] = true;
        if (matchy[v] != -1) {
            q.push(matchy[v]);
            visx[matchy[v]] = true;  // in S
            return false;
        }
        // 找到新的未匹配点 更新匹配点 pre 数组记录着"非匹配边"上与之相连的点
        while (v != -1) {
            matchy[v] = pre[v];
            swap(v, matchx[pre[v]]);
        }
        return true;
    }

    void bfs(int i) {
        while (!q.empty()) {
            q.pop();
        }
        q.push(i);
        visx[i] = true;
        while (true) {
            while (!q.empty()) {
                int u = q.front();
                q.pop();
                for (int v = 0; v < n; v++) {
                    if (!visy[v]) {
                        T delta = lx[u] + ly[v] - g[u][v];
                        if (slack[v] > delta) {
                            pre[v] = u;
                            slack[v] = delta;
                            if (delta) {
                            } else if (check(v)) {  // delta=0
                                                    // 代表有机会加入相等子图
                                                    // 找增广路 找到就return
                                                    // 重建交错树
                                return;
                            }
                        }
                    }
                }
            }
            // 没有增广路 修改顶标
            T a = inf;
            for (int j = 0; j < n; j++) {
                if (!visy[j]) {
                    a = min(a, slack[j]);
                }
            }
            for (int j = 0; j < n; j++) {
                if (visx[j]) {  // S
                    lx[j] -= a;
                }
                if (visy[j]) {  // T
                    ly[j] += a;
                } else {  // T'
                    slack[j] -= a;
                }
            }
            for (int j = 0; j < n; j++) {
                if (!visy[j] && slack[j] == 0 && check(j)) {
                    return;
                }
            }
        }
    }

    void solve() {
        // 初始顶标
        for (int i = 0; i < n; i++) {
            for (int j = 0; j < n; j++) {
                lx[i] = max(lx[i], g[i][j]);
            }
        }

        for (int i = 0; i < n; i++) {
            fill(slack.begin(), slack.end(), inf);
            fill(pre.begin(), pre.end(), 0);
            fill(visx.begin(), visx.end(), false);
            fill(visy.begin(), visy.end(), false);
            bfs(i);
        }

        // custom
        for (int i = 0; i < n; i++) {
            if(matchy[i] != -1) res += g[matchy[i]][i];
        }
        cout << res << "\n";
        for (int i = 0; i < org_n; i++) {
            cout << matchy[i] + 1 << " ";
        }
        cout << "\n";
    }
};

int main() {
    int n, m;
    cin >> n >> m;
    hungarian<long long> h(n, n);
    for (int i = 1, u, v; i <= m; i++) {
        long long w;
        cin >> u >> v >> w;
        u--, v--;
        h.addEdge(u, v, w);
    }
    h.solve();
}
```





## 最小斯坦纳树

```c++
// Problem: P6192 【模板】最小斯坦纳树
// URL: https://www.luogu.com.cn/problem/P6192

// 2023 XJArsen

#include <bits/stdc++.h>

using namespace std;

const int N = 510;
const int INF = 0x3f3f3f3f;
typedef pair<int, int> pii;
int n, m, k;
struct Edge {
    int to;
    long long w;
    Edge(){};
    Edge(int _to, int _w) : to(_to), w(_w) {}
};
vector<Edge> e;
vector<int> g[N], tree;

void add(int u, int v, int w) {
    int tot = e.size();
    tree.emplace_back(v);
    g[u].push_back(tot++);
    e.emplace_back(v, w);

    tree.emplace_back(v);
    g[v].push_back(tot);
    e.emplace_back(u, w);
}

int dp[N][3000], vis[N];
int key[N];
priority_queue<pii, vector<pii>, greater<pii> > q;

void dijkstra(int s) {
    memset(vis, 0, sizeof(vis));

    while (!q.empty()) {
        auto [d1, u] = q.top();
        q.pop();
        if (vis[u]) continue;
        vis[u] = 1;
        for (int i : g[u]) {
            auto [v, d2] = e[i];
            if (dp[tree[i]][s] > dp[u][s] + d2) {
                dp[tree[i]][s] = dp[u][s] + d2;
                q.emplace(dp[tree[i]][s], tree[i]);
            }
        }
    }
}

int main() {
    cin >> n >> m >> k;
    int u, v, w;
    for (int i = 1; i <= m; i++) {
        cin >> u >> v >> w;
        add(u, v, w);
        add(v, u, w);
    }
    
    memset(dp, 0x3f, sizeof(dp));
    for (int i = 1; i <= k; i++) {
        cin >> key[i];
        dp[key[i]][1 << (i - 1)] = 0;
    }
    for (int s = 1; s < (1 << k); s++) {
        for (int i = 1; i <= n; i++) {
            for (int subs = s & (s - 1); subs; subs = s & (subs - 1))
                dp[i][s] = min(dp[i][s], dp[i][subs] + dp[i][s ^ subs]);
            if (dp[i][s] != INF) q.emplace(dp[i][s], i);
        }
        dijkstra(s);
    }
    cout << dp[key[1]][(1 << k) - 1] << "\n";
    return 0;
}

```



## 树链剖分

```c++
int a[N], w[N], p[N];
int top[N], dep[N], id[N], sz[N], son[N];
int res, dfncnt;
vector<int> g[N];

struct tree {
    int laz, r, l, a;
} t[N];

void pushdown(int p, int len) {
    t[p << 1].laz += t[p].laz;
    t[p << 1 | 1].laz += t[p].laz;

    t[p << 1].a = (t[p << 1].a + t[p].laz * (len - len / 2)) % mod;
    t[p << 1 | 1].a = (t[p << 1 | 1].a + t[p].laz * (len / 2)) % mod;

    t[p].laz = 0;
}

void build(int p, int l, int r) {
    t[p].l = l, t[p].r = r;
    if (l == r) {
        t[p].a = w[l];
        return;
    }
    int mid = (l + r) / 2;
    build(p << 1, l, mid);
    build(p << 1 | 1, mid + 1, r);
    t[p].a = (t[p << 1].a + t[p << 1 | 1].a) % mod;
}

void query(int p, int l, int r) {
    if (l <= t[p].l && r >= t[p].r) {
        res = (res + t[p].a) % mod;
        return;
    }
    if (t[p].laz) pushdown(p, (t[p].r - t[p].l + 1));
    int mid = (t[p].l + t[p].r) / 2;
    if (l <= mid) query(p << 1, l, r);
    if (r > mid) query(p << 1 | 1, l, r);
}

void update(int p, int l, int r, int d) {
    if (l <= t[p].l && r >= t[p].r) {
        t[p].laz += d;
        t[p].a = (t[p].a + d * (t[p].r - t[p].l + 1)) % mod;
        return;
    }
    if (t[p].laz) pushdown(p, t[p].r - t[p].l + 1);
    int mid = (t[p].l + t[p].r) / 2;
    if (l <= mid) update(p << 1, l, r, d);
    if (r > mid) update(p << 1 | 1, l, r, d);
    t[p].a = (t[p << 1].a + t[p << 1 | 1].a) % mod;
}

void dfs1(int u, int fa, int deep) {
    dep[u] = deep;
    p[u] = fa;
    sz[u] = 1;
    int mxs = -1;
    for (int v : g[u]) {
        if (v == fa) continue;
        dfs1(v, u, deep + 1);
        sz[u] += sz[v];
        if (sz[v] > mxs) son[u] = v, mxs = sz[v];
    }
}
void dfs2(int u, int topf) {
    id[u] = ++dfncnt;
    w[dfncnt] = a[u];
    top[u] = topf;
    if (!son[u]) return;
    dfs2(son[u], topf);

    for (int v : g[u]) {
        if (v == p[u] || v == son[u]) continue;
        dfs2(v, v);
    }
}

int qrange(int u, int v) {
    int ans = 0;
    while (top[u] != top[v]) {
        if (dep[top[u]] < dep[top[v]]) swap(u, v);
        res = 0;
        query(1, id[top[u]], id[u]);
        ans = (ans + res) % mod;
        u = p[top[u]];
    }
    if (dep[u] > dep[v]) swap(u, v);

    res = 0;
    query(1, id[u], id[v]);
    return (ans + res) % mod;
}

int qson(int u) {
    res = 0;
    query(1, id[u], id[u] + sz[u] - 1);
    return res;
}

void uprange(int u, int v, int k) {
    while (top[u] != top[v]) {
        if (dep[top[u]] < dep[top[v]]) swap(u, v);
        update(1, id[top[u]], id[u], k);
        u = p[top[u]];
    }
    if (dep[u] > dep[v]) swap(u, v);
    update(1, id[u], id[v], k);
}

void upson(int u, int k) { update(1, id[u], id[u] + sz[u] - 1, k); }

```





## 弦图判断

```c++
int n, m;

std::vector<int> vec[N << 1], g[N << 1];
bool vis[N << 1], mrk[N << 1];
int deg[N << 1], arr[N << 1], num[N << 1];

void clear(int n) {
    for (int i = 1; i <= n; i++) {
    	vis[i] = false;
        num[i] = deg[i] = 0;
        std::vector<int>().swap(g[i]);
        std::vector<int>().swap(vec[i]);
    }
}

void mcs() {
    for (int i = 1; i <= n; ++i) vec[0].push_back(i);
    int cnt = n + 1, p = 0;
    while (--cnt) {
        int cur = 0;
        while (!cur) {
            while (!vec[p].empty() && num[vec[p].back()]) {
                vec[p].pop_back();
            }
            if (vec[p].empty()) {
                p--;
            } else {
                cur = vec[p].back();
            }
        }
        arr[cnt] = cur, num[cur] = cnt;
        for (int k : g[cur])
            if (!num[k]) {
                deg[k]++;
                vec[deg[k]].push_back(k);
                if (deg[k] > p) p++;
            }
    }
}

bool check() {
    for (int i = 1; i <= n; i++) {
        int cur = arr[i];
        int mn = n + 1, id = 0, tot = 0;
        vis[cur] = true;
        for (int k : g[cur]) {
            if (!vis[k]) {
                mrk[k] = true, tot++;
                if (num[k] < mn) mn = num[k], id = k;
            }
        }
        if (tot == 0) continue;
        int sum = 1;
        for (int k : g[id]) {
            if (mrk[k] && k != id) sum++;
        }

        for (int k : g[cur]) {
            if (!vis[k]) mrk[k] = false;
        }

        if (sum != tot) return false;
    }
    return true;
}

```



## 建图优化

### 线段树优化建图

> 有 n 个点，m 个连边操作，操作有三种：
>
> `1 x l r a` 从 x向区间[l, r]的点连长度为 �*a* 的边。
>
> `2 x l r a` 从区间[l, r]的点向 x连长度为 a 的边。
>
> `3 x y l r a` 从区间 [x, y] 的点向区间[l, r]的点连长度为 a 的边。
>
> 最后求出 1 到 n 的最短路。
>



对于区间问题，通常用线段树优化。

建两棵线段树，分别为“正线段树”和“反线段树”，正线段树上父亲向儿子连长度为 0 的边，反线段树上儿子向父亲连长度为 0 的边。

对于 1 操作，找到区间 [l, r] 对应的正线段树上的点，从 x 向这些点连长度为 a 的边。

对于 2 操作，找到区间[l, r]对应的反线段树上的点，从这些点向 x 连长度为 a 的边。

对于 3 操作，新建一个虚点，从 [x, y] 对应的反线段树上的点向虚点连长度为 00 的边，从虚点向 [l, r] 对应的正线段树上的点连长度为 *a* 的边。

```C++
// Problem: B. Legacy
// URL: https://codeforces.com/problemset/problem/786/B

// 2023 XJArsen

#include <bits/stdc++.h>
using namespace std;
#define int long long

using pii = pair<int, int>;
using ll = long long;
const int INF = 0x7f7f7f7f7f7f7f7f;
const int N = 2e6 + 10, K = 4e5 + 10;
vector<pii> g[N];
int n, q, s;

void add(int u, int v, int w) { g[u].emplace_back(v, w); }

struct {
    int l, r;
    int dat;
} t[N * 2];
// build(1, 1, n);
void build(int p, int l, int r) {
    t[p].l = l, t[p].r = r;
    if (l == r) {
        t[l].dat = p;
        return;
    }
    int mid = (l + r) / 2;
    add(p, p * 2, 0), add(p * 2 + K, p + K, 0);
    add(p, p * 2 + 1, 0), add(p * 2 + 1 + K, p + K, 0);

    build(p * 2, l, mid);
    build(p * 2 + 1, mid + 1, r);
}

void change(int p, int l, int r, int v, int w, int op) {
    if (l <= t[p].l && r >= t[p].r) {
        op ? add(p + K, v, w) : add(v + K, p, w);
        return;
    }
    int mid = (t[p].r + t[p].l) / 2;
    if (l <= mid) change(p * 2, l, r, v, w, op);
    if (r > mid) change(p * 2 + 1, l, r, v, w, op);
}
int dist[N];
bool vis[N];
void dijkstra(int s) {
    memset(dist, 0x7f, sizeof dist);
    dist[s] = 0;
    priority_queue<pii, vector<pii>, greater<pii>> q;
    q.emplace(0, s);

    while (q.size()) {
        auto t = q.top();
        q.pop();
        int u = t.second, d1 = t.first;
        if (vis[u]) continue;
        vis[u] = true;
        for (auto [v, d2] : g[u]) {
            if (dist[v] > d1 + d2) {
                dist[v] = d1 + d2;
                q.emplace(dist[v], v);
            }
        }
    }
}
void Solve() {
    cin >> n >> q >> s;
    build(1, 1, n);

    for (int i = 0; i <= n; i++) {
        add(t[i].dat + K, t[i].dat, 0);
        add(t[i].dat, t[i].dat + K, 0);
    }
    int op, v, w;

    while (q--) {
        cin >> op;
        if (op == 1) {
            int u;
            cin >> v >> u >> w;
            add(t[v].dat + K, t[u].dat, w);
        } else {
            int l, r;
            cin >> v >> l >> r >> w;
            change(1, l, r, t[v].dat, w, op % 2);
        }
    }

    dijkstra(t[s].dat + K);
    for (int i = 1; i <= n; i++) {
        cout << (dist[t[i].dat] == INF ? -1 : dist[t[i].dat]) << " ";
    }
}

signed main() {
    ios::sync_with_stdio(false);
    cin.tie(0), cout.tie(0);
    int _ = 1;
    // cin >> _;
    while (_--) {
        Solve();
    }
    return 0;
}
```



### 前后缀优化建图

> 有 *n* 个点，*m* 个连边操作，操作有三种：
>
> `1 x l r a` 从 *x* 向区间 [l， r] 以外的点连长度为 *a* 的边。
>
> `2 x l r a` 从区间 [l, r] 以外的点向 *x* 连长度为 *a* 的边。
>
> `3 x y l r a` 从区间 [x, y] 以外的点向区间 [l, r] 以外的点连长度为 a 的边。
>
> 最后求出 1 到 *n* 的最短路。







## 支配树

```c++
struct DominatorTree{
    std::vector <std::vector <int>> e, _e, tmp;
    std::vector <int> dfn, inv;
    int dfncnt;
    std::vector <int> sdom, idom;
    std::vector <int> fa, father, value;

    explicit DominatorTree(int n):dfncnt(0){
        int sz = n + 10;
        e.resize(sz);
        _e.resize(sz);
        tmp.resize(sz);
        dfn.resize(sz);
        inv.resize(sz);
        sdom.resize(sz);
        idom.resize(sz);
        fa.resize(sz);
        father.resize(sz);
        value.resize(sz);
    }

    void add_edge(int u, int v){
        e[u].emplace_back(v);
        _e[v].emplace_back(u);
    }

    int min(int u, int v){
        return dfn[u] < dfn[v] ? u : v;
    }

    int find(int u){
        if (fa[u] == u) return u;
        int f = fa[u];
        fa[u] = find(fa[u]);
        if (dfn[sdom[value[f]]] < dfn[sdom[value[u]]]) value[u] = value[f];
        return fa[u];
    }

    void dfs(int u){
        dfn[u] = ++ dfncnt;
        inv[dfncnt] = u;
        for (auto v : e[u]){
            if (dfn[v]){
                continue;
            }
            father[v] = u;
            dfs(v);
        }
    }

    void solve(int rt){
        dfs(rt);
        for (int i = 1; i <= dfncnt; ++ i){
            fa[inv[i]] = value[inv[i]] = sdom[inv[i]] = inv[i];
        }
        for (int i = dfncnt; i >= 2; -- i){
            int u = inv[i];
            for (auto v : _e[u]){
                if (!dfn[v]) continue;
                if (dfn[v] < i){
                    sdom[u] = min(sdom[u], v);
                }
                else{
                    find(v);
                    sdom[u] = min(sdom[u], sdom[value[v]]);
                }
            }
            fa[u] = father[u];
            tmp[sdom[u]].emplace_back(u);
            int pa = fa[u];
            for (auto v : tmp[pa]){
                find(v);
                idom[v] = value[v];
            }
            tmp[pa].clear();
        }
        for (int i = 2; i <= dfncnt; ++ i){
            int u = inv[i];
            idom[u] = sdom[u] == sdom[idom[u]] ? sdom[u] : idom[idom[u]];
        }
    }
};

struct DfsOrder{

    std::vector <std::vector <int>> e;
    std::vector <int> dfn, right, dep;
    int dfn_cnt;
    int n, root;

    explicit DfsOrder(int sz, int root):n(sz), dfn_cnt(0), root(root){
        sz += 10;
        e.resize(sz);
        dfn.resize(sz);
        right.resize(sz);
        dep.resize(sz);
    }

    void add_edge(int u, int v){
        e[u].emplace_back(v);
        e[v].emplace_back(u);
    }

    void dfs(int u, int fa){
        dfn[u] = ++ dfn_cnt;
        for (auto v : e[u]){
            if (v == fa){
                continue;
            }
            dep[v] = dep[u] + 1;
            dfs(v, u);
        }
        right[u] = dfn_cnt;
    }

    void solve(){
        dfs(root, 0);
    }

    bool is_son(int u, int v){
        return dfn[u] <= dfn[v] && right[v] <= right[u];
    }
};
```



## 优化建图

[常见优化建图技巧 - - 洛谷博客 (luogu.com.cn)](https://www.luogu.com.cn/blog/221955/chang-jian-you-hua-jian-tu-ji-qiao)

### 线段树优化建图

```c++
// Problem: B. Legacy
// URL: https://codeforces.com/problemset/problem/786/B

// 2023 XJArsen

#include <bits/stdc++.h>
using namespace std;
#define int long long

using pii = pair<int, int>;
using ll = long long;
const int INF = 0x7f7f7f7f7f7f7f7f;
const int N = 2e6 + 10, K = 4e5 + 10;
vector<pii> g[N];
int n, q, s;

void add(int u, int v, int w) { g[u].emplace_back(v, w); }

struct {
    int l, r;
    int dat;
} t[N * 2];
// build(1, 1, n);
void build(int p, int l, int r) {
    t[p].l = l, t[p].r = r;
    if (l == r) {
        t[l].dat = p;
        return;
    }
    int mid = (l + r) / 2;
    add(p, p * 2, 0), add(p * 2 + K, p + K, 0);
    add(p, p * 2 + 1, 0), add(p * 2 + 1 + K, p + K, 0);

    build(p * 2, l, mid);
    build(p * 2 + 1, mid + 1, r);
}

void change(int p, int l, int r, int v, int w, int op) {
    if (l <= t[p].l && r >= t[p].r) {
        op ? add(p + K, v, w) : add(v + K, p, w);
        return;
    }
    int mid = (t[p].r + t[p].l) / 2;
    if (l <= mid) change(p * 2, l, r, v, w, op);
    if (r > mid) change(p * 2 + 1, l, r, v, w, op);
}
int dist[N];
bool vis[N];
void dijkstra(int s) {
    memset(dist, 0x7f, sizeof dist);
    dist[s] = 0;
    priority_queue<pii, vector<pii>, greater<pii>> q;
    q.emplace(0, s);

    while (q.size()) {
        auto t = q.top();
        q.pop();
        int u = t.second, d1 = t.first;
        if (vis[u]) continue;
        vis[u] = true;
        for (auto [v, d2] : g[u]) {
            if (dist[v] > d1 + d2) {
                dist[v] = d1 + d2;
                q.emplace(dist[v], v);
            }
        }
    }
}
void Solve() {
    cin >> n >> q >> s;
    build(1, 1, n);

    for (int i = 0; i <= n; i++) {
        add(t[i].dat + K, t[i].dat, 0);
        add(t[i].dat, t[i].dat + K, 0);
    }
    int op, v, w;

    while (q--) {
        cin >> op;
        if (op == 1) {
            int u;
            cin >> v >> u >> w;
            add(t[v].dat + K, t[u].dat, w);
        } else {
            int l, r;
            cin >> v >> l >> r >> w;
            change(1, l, r, t[v].dat, w, op % 2);
        }
    }

    dijkstra(t[s].dat + K);
    for (int i = 1; i <= n; i++) {
        cout << (dist[t[i].dat] == INF ? -1 : dist[t[i].dat]) << " ";
    }
}

signed main() {
    ios::sync_with_stdio(false);
    cin.tie(0), cout.tie(0);
    int _ = 1;
    // cin >> _;
    while (_--) {
        Solve();
    }
    return 0;
}
```



### 前后缀优化建图

```c++
// Problem: P6378 [PA2010] Riddle
// URL: https://www.luogu.com.cn/problem/P6378

// 2023 XJArsen

#include <bits/stdc++.h>
using namespace std;

const int N = 1e6 + 10;

int dfn[N << 2], low[N << 2], dfncnt, s[N << 2], tp;
int scc[N << 2], sc;  // 结点 i 所在 SCC 的编号
bool vis[N << 2];
vector<int> g[N << 2];
void add(int a, int b) { g[a].emplace_back(b); }
void tarjan(int u) {
    low[u] = dfn[u] = ++dfncnt;
    s[++tp] = u, vis[u] = 1;
    for (int v : g[u]) {
        if (!dfn[v]) {
            tarjan(v);
            low[u] = min(low[u], low[v]);
        } else if (vis[v]) {
            low[u] = min(low[u], dfn[v]);
        }
    }
    if (dfn[u] == low[u]) {
        ++sc;
        while (s[tp] != u) {
            scc[s[tp]] = sc;
            vis[s[tp]] = 0;
            --tp;
        }
        scc[s[tp]] = sc;
        vis[s[tp]] = 0;
        --tp;
    }
}
int p[N];
void Solve() {
    int n, m, k;
    cin >> n >> m >> k;

    for (int i = 1, a, b; i <= m; i++) {
        cin >> a >> b;
        add(a, b + n);
        add(b, a + n);
    }
    
    for (int i = 1, w; i <= k; i++)  {
    	cin >> w;
    	for (int j = 1; j <= w; j++) {
    		cin >> p[j];
    		add(p[j] + 2 * n, p[j]);
    		add(p[j] + 3 * n, p[j]);
    	}
    	
    	for (int j = 1; j < w; j++) {
    		add(p[j + 1] + 2 * n, p[j] + 2 * n);
			add(p[j] + 3 * n, p[j + 1] + 3 * n);
			add(p[j + 1] + n, p[j] + 2 * n);
			add(p[j] + n, p[j + 1] + 3 * n);
    	}
    }
    
    for (int i = 1; i <= 2 * n; i++) {
    	if(!dfn[i]) tarjan(i);
    }
    
    for (int i = 1; i <= n; i++) {
    	if(scc[i] == scc[i + n]) {
    		return cout << "NIE", void();
    	}
    }
    cout << "TAK";
}

signed main() {
    ios::sync_with_stdio(false);
    cin.tie(0), cout.tie(0);
    int _ = 1;
    // cin >> _;
    while (_--) {
        Solve();
    }
    return 0;
}
```



# 动态规划

## 背包DP

### 01背包

```c++
for (int i = 1; i <= n; i++) {
    for (int j = m; j >= v[i]; j--) {
        dp[j] = max(dp[j], dp[j - v[i]] + w[i]);
    }
}
```

### 完全背包

```
for(int i = 1;i <= n; i++){
	for(int j = v[i];j <= m; j++){
		dp[j] = max(dp[j],dp[j - v[i]] + w[i]);
	}
}
```

### 多重背包

```c++
for (int i = 1; i <= n; i++) {
    int a, b, s;
    cin >> a >> b >> s;
    int k = 1;
    while (k <= s) {
        cnt++;
        v[cnt] = a * k;
        w[cnt] = b * k;
        s -= k;
        k <<= 1;
    }
    if (s > 0) {
        cnt++;
        v[cnt] = a * s;
        w[cnt] = b * s;
    }
}
for (int i = 1; i <= cnt; i++) {
    for (int j = m; j >= v[i]; j--) {
        dp[j] = max(dp[j], dp[j - v[i]] + w[i]);
    }
}
```

### 分组背包

```
for (int i = 1; i <= n; i++) {
    for (int j = m; j >= 0; j--) {
        for (int k = 0; k < s[i]; k++) {
            if (v[i][k] <= j) {
                f[j] = max(f[j], f[j - v[i][k]] + w[i][k]);
            }
        }
    }
}
```



## 树形DP

### 树的中心

计算树上每个点到其他点的最长距离

```
int dfs_d(int u, int fa) {
    d1[u] = d2[u] = -INF;
    for (auto i : g[u]) {
        int v = i.fi, w = i.se;
        if (fa == v) continue;

        int d = dfs_d(v, u) + w;
        if (d > d1[u]) {
            d2[u] = d1[u], d1[u] = d, p[u] = v;
        } else if (d > d2[u]) {
            d2[u] = d;
        }
    }
    if (d1[u] == -INF) 
        d1[u] = d2[u] = 0;
    
    return d1[u];
}

void dfs_u(int u, int fa) {
    for (auto i : g[u]) {
        int v = i.fi, w = i.se;
        if (fa == v) continue;
        if (p[u] == v) {
            up[v] = max(up[u], d2[u]) + w;
        } else {
            up[v] = max(up[u], d1[u]) + w;
        }
        dfs_u(v, u);
    }
}
```

### 树的直径

```c++
int dfs(int u, int fa) {
    int dist = 0;
    int d1 = 0, d2 = 0;
    for (auto [v, w] : g[u]) {
        if (v == fa) continue;
        int d = dfs(v, u) + w;
        dist = max(dist, d);
        if (d >= d1) {
            d2 = d1,d1 = d;
        } else if (d > d2) {
            d2 = d;
        }
    }
    mxd = max(mxd, d1 + d2);
    return dist;
}
```

### 换根dp

换根DP的套路：

1，指定某个节点为根节点。

2，第一次搜索完成预处理（如子树大小等），同时得到该节点的解。

3，第二次搜索进行换根的动态规划，由已知解的节点推出相连节点的解。



# 计算几何

## 二维计算几何

```c++
#include <bits/stdc++.h>
template <class T>
struct Point {
    T x;
    T y;
    Point(T x_ = 0, T y_ = 0) : x(x_), y(y_) {}

    template <class U>
    operator Point<U>() {
        return Point<U>(U(x), U(y));
    }
    Point &operator+=(Point p) & {
        x += p.x;
        y += p.y;
        return *this;
    }
    Point &operator-=(Point p) & {
        x -= p.x;
        y -= p.y;
        return *this;
    }
    Point &operator*=(T v) & {
        x *= v;
        y *= v;
        return *this;
    }
    Point operator-() const { return Point(-x, -y); }
    friend Point operator+(Point a, Point b) { return a += b; }
    friend Point operator-(Point a, Point b) { return a -= b; }
    friend Point operator*(Point a, T b) { return a *= b; }
    friend Point operator*(T a, Point b) { return b *= a; }
    friend bool operator==(Point a, Point b) {
        return a.x == b.x && a.y == b.y;
    }
    friend std::istream &operator>>(std::istream &is, Point &p) {
        return is >> p.x >> p.y;
    }
    friend std::ostream &operator<<(std::ostream &os, Point p) {
        return os << "(" << p.x << ", " << p.y << ")";
    }
};
// 点乘
template <class T>
T dot(Point<T> a, Point<T> b) {
    return a.x * b.x + a.y * b.y;
}
// 叉乘
template <class T>
T cross(Point<T> a, Point<T> b) {
    return a.x * b.y - a.y * b.x;
}
// 平方
template <class T>
T square(Point<T> p) {
    return dot(p, p);
}
// 求向量的长度
template <class T>
double length(Point<T> p) {
    return std::sqrt(double(square(p)));
}

long double length(Point<long double> p) { return std::sqrt(square(p)); }
// 直线
template <class T>
struct Line {
    Point<T> a;
    Point<T> b;
    Line(Point<T> a_ = Point<T>(), Point<T> b_ = Point<T>()) : a(a_), b(b_) {}
};
// 逆时针90°旋转点
template <class T>
Point<T> rotate(Point<T> a) {
    return Point(-a.y, a.x);
}

template <class T>
int sgn(Point<T> a) {
    return a.y > 0 || (a.y == 0 && a.x > 0) ? 1 : -1;
}
// 点到直线的距离
template <class T>
bool pointOnLineLeft(Point<T> p, Line<T> l) {
    return cross(l.b - l.a, p - l.a) > 0;
}
// 两直线交点
template <class T>
Point<T> lineIntersection(Line<T> l1, Line<T> l2) {
    return l1.a + (l1.b - l1.a) * (cross(l2.b - l2.a, l1.a - l2.a) /
                                   cross(l2.b - l2.a, l1.a - l1.b));
}
// 判断点在线段上
template <class T>
bool pointOnSegment(Point<T> p, Line<T> l) {
    return cross(p - l.a, l.b - l.a) == 0 && std::min(l.a.x, l.b.x) <= p.x &&
           p.x <= std::max(l.a.x, l.b.x) && std::min(l.a.y, l.b.y) <= p.y &&
           p.y <= std::max(l.a.y, l.b.y);
}
// 判断点在多边形内
template <class T>
bool pointInPolygon(Point<T> a, std::vector<Point<T>> p) {
    int n = p.size();
    for (int i = 0; i < n; i++) {
        if (pointOnSegment(a, Line(p[i], p[(i + 1) % n]))) {
            return true;
        }
    }

    int t = 0;
    for (int i = 0; i < n; i++) {
        auto u = p[i];
        auto v = p[(i + 1) % n];
        if (u.x < a.x && v.x >= a.x && pointOnLineLeft(a, Line(v, u))) {
            t ^= 1;
        }
        if (u.x >= a.x && v.x < a.x && pointOnLineLeft(a, Line(u, v))) {
            t ^= 1;
        }
    }

    return t == 1;
}

// 两线段相交
// 0 : not intersect
// 1 : strictly intersect
// 2 : overlap
// 3 : intersect at endpoint
template <class T>
std::tuple<int, Point<T>, Point<T>> segmentIntersection(Line<T> l1,
                                                        Line<T> l2) {
    if (std::max(l1.a.x, l1.b.x) < std::min(l2.a.x, l2.b.x)) {
        return {0, Point<T>(), Point<T>()};
    }
    if (std::min(l1.a.x, l1.b.x) > std::max(l2.a.x, l2.b.x)) {
        return {0, Point<T>(), Point<T>()};
    }
    if (std::max(l1.a.y, l1.b.y) < std::min(l2.a.y, l2.b.y)) {
        return {0, Point<T>(), Point<T>()};
    }
    if (std::min(l1.a.y, l1.b.y) > std::max(l2.a.y, l2.b.y)) {
        return {0, Point<T>(), Point<T>()};
    }
    if (cross(l1.b - l1.a, l2.b - l2.a) == 0) {
        if (cross(l1.b - l1.a, l2.a - l1.a) != 0) {
            return {0, Point<T>(), Point<T>()};
        } else {
            auto maxx1 = std::max(l1.a.x, l1.b.x);
            auto minx1 = std::min(l1.a.x, l1.b.x);
            auto maxy1 = std::max(l1.a.y, l1.b.y);
            auto miny1 = std::min(l1.a.y, l1.b.y);
            auto maxx2 = std::max(l2.a.x, l2.b.x);
            auto minx2 = std::min(l2.a.x, l2.b.x);
            auto maxy2 = std::max(l2.a.y, l2.b.y);
            auto miny2 = std::min(l2.a.y, l2.b.y);
            Point<T> p1(std::max(minx1, minx2), std::max(miny1, miny2));
            Point<T> p2(std::min(maxx1, maxx2), std::min(maxy1, maxy2));
            if (!pointOnSegment(p1, l1)) {
                std::swap(p1.y, p2.y);
            }
            if (p1 == p2) {
                return {3, p1, p2};
            } else {
                return {2, p1, p2};
            }
        }
    }
    auto cp1 = cross(l2.a - l1.a, l2.b - l1.a);
    auto cp2 = cross(l2.a - l1.b, l2.b - l1.b);
    auto cp3 = cross(l1.a - l2.a, l1.b - l2.a);
    auto cp4 = cross(l1.a - l2.b, l1.b - l2.b);

    if ((cp1 > 0 && cp2 > 0) || (cp1 < 0 && cp2 < 0) || (cp3 > 0 && cp4 > 0) ||
        (cp3 < 0 && cp4 < 0)) {
        return {0, Point<T>(), Point<T>()};
    }

    Point p = lineIntersection(l1, l2);
    if (cp1 != 0 && cp2 != 0 && cp3 != 0 && cp4 != 0) {
        return {1, p, p};
    } else {
        return {3, p, p};
    }
}
// 线段在四边形内
template <class T>
bool segmentInPolygon(Line<T> l, std::vector<Point<T>> p) {
    int n = p.size();
    if (!pointInPolygon(l.a, p)) {
        return false;
    }
    if (!pointInPolygon(l.b, p)) {
        return false;
    }
    for (int i = 0; i < n; i++) {
        auto u = p[i];
        auto v = p[(i + 1) % n];
        auto w = p[(i + 2) % n];
        auto [t, p1, p2] = segmentIntersection(l, Line(u, v));

        if (t == 1) {
            return false;
        }
        if (t == 0) {
            continue;
        }
        if (t == 2) {
            if (pointOnSegment(v, l) && v != l.a && v != l.b) {
                if (cross(v - u, w - v) > 0) {
                    return false;
                }
            }
        } else {
            if (p1 != u && p1 != v) {
                if (pointOnLineLeft(l.a, Line(v, u)) ||
                    pointOnLineLeft(l.b, Line(v, u))) {
                    return false;
                }
            } else if (p1 == v) {
                if (l.a == v) {
                    if (pointOnLineLeft(u, l)) {
                        if (pointOnLineLeft(w, l) &&
                            pointOnLineLeft(w, Line(u, v))) {
                            return false;
                        }
                    } else {
                        if (pointOnLineLeft(w, l) ||
                            pointOnLineLeft(w, Line(u, v))) {
                            return false;
                        }
                    }
                } else if (l.b == v) {
                    if (pointOnLineLeft(u, Line(l.b, l.a))) {
                        if (pointOnLineLeft(w, Line(l.b, l.a)) &&
                            pointOnLineLeft(w, Line(u, v))) {
                            return false;
                        }
                    } else {
                        if (pointOnLineLeft(w, Line(l.b, l.a)) ||
                            pointOnLineLeft(w, Line(u, v))) {
                            return false;
                        }
                    }
                } else {
                    if (pointOnLineLeft(u, l)) {
                        if (pointOnLineLeft(w, Line(l.b, l.a)) ||
                            pointOnLineLeft(w, Line(u, v))) {
                            return false;
                        }
                    } else {
                        if (pointOnLineLeft(w, l) ||
                            pointOnLineLeft(w, Line(u, v))) {
                            return false;
                        }
                    }
                }
            }
        }
    }
    return true;
}

template <class T>
std::vector<Point<T>> hp(std::vector<Line<T>> lines) {
    std::sort(lines.begin(), lines.end(), [&](auto l1, auto l2) {
        auto d1 = l1.b - l1.a;
        auto d2 = l2.b - l2.a;

        if (sgn(d1) != sgn(d2)) {
            return sgn(d1) == 1;
        }

        return cross(d1, d2) > 0;
    });

    std::deque<Line<T>> ls;
    std::deque<Point<T>> ps;
    for (auto l : lines) {
        if (ls.empty()) {
            ls.push_back(l);
            continue;
        }

        while (!ps.empty() && !pointOnLineLeft(ps.back(), l)) {
            ps.pop_back();
            ls.pop_back();
        }

        while (!ps.empty() && !pointOnLineLeft(ps[0], l)) {
            ps.pop_front();
            ls.pop_front();
        }

        if (cross(l.b - l.a, ls.back().b - ls.back().a) == 0) {
            if (dot(l.b - l.a, ls.back().b - ls.back().a) > 0) {
                if (!pointOnLineLeft(ls.back().a, l)) {
                    assert(ls.size() == 1);
                    ls[0] = l;
                }
                continue;
            }
            return {};
        }

        ps.push_back(lineIntersection(ls.back(), l));
        ls.push_back(l);
    }

    while (!ps.empty() && !pointOnLineLeft(ps.back(), ls[0])) {
        ps.pop_back();
        ls.pop_back();
    }
    if (ls.size() <= 2) {
        return {};
    }
    ps.push_back(lineIntersection(ls[0], ls.back()));

    return std::vector(ps.begin(), ps.end());
}
```

## 凸包

```c++
struct Point {
    double x, y;
    Point() {}
    Point(int x, int y) : x(x), y(y) {}
    void read() { scanf("%lf%lf", &x, &y); }
    bool operator<(const Point &other) const {
        if (x == other.x) return y < other.y;
        return x < other.x;
    }
    bool operator==(const Point &other) const {
        return x == other.x && y == other.y;
    }
    Point operator-(const Point &other) const {
        return Point(x - other.x, y - other.y);
    }

} p[N];
int sta[N], used[N];
double Cross(Point A, Point B) { return A.x * B.y - A.y * B.x; }
double d(Point p1, Point p2) {
    return sqrt((p2.y - p1.y) * (p2.y - p1.y) + (p2.x - p1.x) * (p2.x - p1.x));
}
double Side(Point a, Point b, Point p) {
    Point A = Point(b.x - a.x, b.y - a.y);  //向量ab
    Point B = Point(p.x - b.x, p.y - b.y);  //向量ap
    return Cross(A, B);
}
double ConvexHull() {
    sort(p + 1, p + 1 + n);
    if (n < 3) return 0;
    int top = 0;
    sta[++top] = 1;
    for (int i = 2; i <= n; i++) {
        while (top >= 2 && Side(p[sta[top - 1]], p[sta[top]], p[i]) <= 0) {
            used[sta[top--]] = false;
        }
        used[i] = true;
        sta[++top] = i;
    }
    int tmp = top;
    for (int i = n - 1; i > 0; i--) {
        if (!used[i]) {
            while (top > tmp && Side(p[sta[top - 1]], p[sta[top]], p[i]) <= 0) {
                used[sta[top--]] = false;
            }
            used[i] = true;

            sta[++top] = i;
        }
    }
    double ans = 0;

    for (int i = 1; i < top; i++) {
        ans += d(p[sta[i]], p[sta[i + 1]]);
    }
    return ans;
}

```







# 常用技巧

## 快读快写
```c++
inline int read() {
    int x = 0, f = 1;
    char ch = getchar();
    while (ch < '0' || ch > '9') {
        if (ch == '-') f = -1;
        ch = getchar();
    }
    while (ch >= '0' && ch <= '9') x = x * 10 + ch - '0', ch = getchar();
    return x * f;
}
```
```C++
inline void write(int x) {
    if (x < 0) putchar('-'), x = -x;
    if (x > 9) write(x / 10);
    putchar(x % 10 + '0');
    return;
}
```



## O2优化

```C++
#pragma GCC optimize(1)
#pragma GCC optimize(2)
```



## 对拍

```C++
int t = 0;
while(true) {
    printf("test #%d: ", ++t);
    system("make.exe > data.in");
    system("std.exe < data.in > data.ans");
    system("code.exe < data.in > data.out");
    if(system("fc data.out data.ans > data.log")) {
        printf("Wrong Answer\n"); 
        break;
    }
    else printf("Accepted\n");
}
```



## unordered_map 重载hash

```c++
struct pair_hash {
	template<class T1, class T2>
	size_t operator() (const pair<T1, T2>& pair) const {
		return hash<T1>()(pair.first) ^ hash<T2>()(pair.second);
	}
};
```



## 取模运算 modint

```c++
template <class T>
constexpr T power(T a, long long b) {
    T res = 1;
    for (; b; b /= 2, a *= a) {
        if (b % 2) {
            res *= a;
        }
    }
    return res;
}

constexpr long long mul(long long a, long long b, long long p) {
    long long res = a * b - (long long)(1.L * a * b / p) * p;
    res %= p;
    if (res < 0) {
        res += p;
    }
    return res;
}
template <long long P>
struct MLong {
    long long x;
    constexpr MLong() : x{} {}
    constexpr MLong(long long x) : x{norm(x % getMod())} {}

    static long long Mod;
    constexpr static long long getMod() {
        if (P > 0) {
            return P;
        } else {
            return Mod;
        }
    }
    constexpr static void setMod(long long Mod_) { Mod = Mod_; }
    constexpr long long norm(long long x) const {
        if (x < 0) {
            x += getMod();
        }
        if (x >= getMod()) {
            x -= getMod();
        }
        return x;
    }
    constexpr long long val() const { return x; }
    explicit constexpr operator long long() const { return x; }
    constexpr MLong operator-() const {
        MLong res;
        res.x = norm(getMod() - x);
        return res;
    }
    constexpr MLong inv() const {
        assert(x != 0);
        return power(*this, getMod() - 2);
    }
    constexpr MLong &operator*=(MLong rhs) & {
        x = mul(x, rhs.x, getMod());
        return *this;
    }
    constexpr MLong &operator+=(MLong rhs) & {
        x = norm(x + rhs.x);
        return *this;
    }
    constexpr MLong &operator-=(MLong rhs) & {
        x = norm(x - rhs.x);
        return *this;
    }
    constexpr MLong &operator/=(MLong rhs) & { return *this *= rhs.inv(); }
    friend constexpr MLong operator*(MLong lhs, MLong rhs) {
        MLong res = lhs;
        res *= rhs;
        return res;
    }
    friend constexpr MLong operator+(MLong lhs, MLong rhs) {
        MLong res = lhs;
        res += rhs;
        return res;
    }
    friend constexpr MLong operator-(MLong lhs, MLong rhs) {
        MLong res = lhs;
        res -= rhs;
        return res;
    }
    friend constexpr MLong operator/(MLong lhs, MLong rhs) {
        MLong res = lhs;
        res /= rhs;
        return res;
    }
    friend constexpr std::istream &operator>>(std::istream &is, MLong &a) {
        long long v;
        is >> v;
        a = MLong(v);
        return is;
    }
    friend constexpr std::ostream &operator<<(std::ostream &os,
                                              const MLong &a) {
        return os << a.val();
    }
    friend constexpr bool operator==(MLong lhs, MLong rhs) {
        return lhs.val() == rhs.val();
    }
    friend constexpr bool operator!=(MLong lhs, MLong rhs) {
        return lhs.val() != rhs.val();
    }
};

template <int P>
struct MInt {
    int x;
    constexpr MInt() : x{} {}
    constexpr MInt(long long x) : x{norm(x % getMod())} {}

    static int Mod;
    constexpr static int getMod() {
        if (P > 0) {
            return P;
        } else {
            return Mod;
        }
    }
    constexpr static void setMod(int Mod_) { Mod = Mod_; }
    constexpr int norm(int x) const {
        if (x < 0) {
            x += getMod();
        }
        if (x >= getMod()) {
            x -= getMod();
        }
        return x;
    }
    constexpr int val() const { return x; }
    explicit constexpr operator int() const { return x; }
    constexpr MInt operator-() const {
        MInt res;
        res.x = norm(getMod() - x);
        return res;
    }
    constexpr MInt inv() const {
        assert(x != 0);
        return power(*this, getMod() - 2);
    }
    constexpr MInt &operator*=(MInt rhs) & {
        x = 1LL * x * rhs.x % getMod();
        return *this;
    }
    constexpr MInt &operator+=(MInt rhs) & {
        x = norm(x + rhs.x);
        return *this;
    }
    constexpr MInt &operator-=(MInt rhs) & {
        x = norm(x - rhs.x);
        return *this;
    }
    constexpr MInt &operator/=(MInt rhs) & { return *this *= rhs.inv(); }
    friend constexpr MInt operator*(MInt lhs, MInt rhs) {
        MInt res = lhs;
        res *= rhs;
        return res;
    }
    friend constexpr MInt operator+(MInt lhs, MInt rhs) {
        MInt res = lhs;
        res += rhs;
        return res;
    }
    friend constexpr MInt operator-(MInt lhs, MInt rhs) {
        MInt res = lhs;
        res -= rhs;
        return res;
    }
    friend constexpr MInt operator/(MInt lhs, MInt rhs) {
        MInt res = lhs;
        res /= rhs;
        return res;
    }
    friend constexpr std::istream &operator>>(std::istream &is, MInt &a) {
        long long v;
        is >> v;
        a = MInt(v);
        return is;
    }
    friend constexpr std::ostream &operator<<(std::ostream &os, const MInt &a) {
        return os << a.val();
    }
    friend constexpr bool operator==(MInt lhs, MInt rhs) {
        return lhs.val() == rhs.val();
    }
    friend constexpr bool operator!=(MInt lhs, MInt rhs) {
        return lhs.val() != rhs.val();
    }
};
template <>
int MInt<0>::Mod = 998244353;
template <int V, int P>
constexpr MInt<P> CInv = MInt<P>(V).inv();
using Z = MInt<0>;
```